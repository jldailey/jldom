var privates = {};
// Generated by CoffeeScript 1.3.3
(function() {
  var clear, entity_table, escape, get, parse, unescape, void_elements,
    __slice = [].slice,
    __indexOf = [].indexOf || function(item) { for (var i = 0, l = this.length; i < l; i++) { if (i in this && this[i] === item) return i; } return -1; };

  clear = function() {
    var a, i, _i, _len, _results;
    a = 1 <= arguments.length ? __slice.call(arguments, 0) : [];
    _results = [];
    for (_i = 0, _len = a.length; _i < _len; _i++) {
      i = a[_i];
      _results.push(i.length = 0);
    }
    return _results;
  };

  get = function(a) {
    return a.join("");
  };

  void_elements = ["AREA", "BASE", "BR", "COL", "COMMAND", "EMBED", "HR", "IMG", "INPUT", "KEYGEN", "LINK", "META", "PARAM", "SOURCE", "TRACK", "WBR"];

  parse = function(input, document) {
    var attrName, attrVal, attributes, c, closeNode, cursor, emitAttr, emitComment, emitNode, emitText, fragment, i, m, mode, parseError, result, states, tagName, text, x, _i, _len;
    i = 0;
    mode = 0;
    fragment = document.createDocumentFragment();
    cursor = fragment;
    tagName = [];
    attrName = [];
    attrVal = [];
    text = [];
    attributes = {};
    closeNode = function() {
      var t;
      t = get(tagName).toUpperCase();
      clear(tagName);
      if (__indexOf.call(void_elements, t) >= 0) {
        return;
      }
      return cursor = cursor.parentNode;
    };
    emitNode = function(closing) {
      return function() {
        var a, node, _ref;
        if (tagName.length > 0) {
          node = document.createElement(get(tagName));
          for (a in attributes) {
            node.setAttribute(a, attributes[a]);
          }
          cursor.appendChild(node);
          cursor = node;
          clear(text, tagName, attrName, attrVal);
          for (a in attributes) {
            delete attributes[a];
          }
          if (closing || (_ref = node.nodeName, __indexOf.call(void_elements, _ref) >= 0)) {
            return closeNode();
          }
        }
      };
    };
    emitAttr = function() {
      var k, v;
      k = get(attrName);
      v = get(attrVal);
      if (k != null) {
        k = k.replace(/^\s+/, '');
      }
      if (k !== "") {
        attributes[k] = v || "";
      }
      return clear(attrName, attrVal);
    };
    emitText = function() {
      if (text.length > 0) {
        cursor.appendChild(document.createTextNode(get(text)));
        return clear(text);
      }
    };
    emitComment = function() {
      if (text.length > 0) {
        cursor.appendChild(document.createComment(get(text)));
        return clear(text);
      }
    };
    parseError = function(msg) {
      return function() {
        throw "Parse error: " + msg;
      };
    };
    states = [
      {
        "<": [emitText, 1],
        "": [text, 0]
      }, {
        "/": [9],
        "!": [10],
        "": [tagName, 2]
      }, {
        " ": [3],
        "/": [8],
        ">": [emitNode(false), 0],
        "": [tagName]
      }, {
        "=": [4],
        " ": [emitAttr, 3],
        "/": [emitAttr, 8],
        ">": [emitAttr, emitNode(false), 0],
        "": [attrName]
      }, {
        '"': [5],
        "'": [6],
        "": [attrVal, 7]
      }, {
        '"': [emitAttr, 2],
        "": [attrVal]
      }, {
        "'": [emitAttr, 2],
        "": [attrVal]
      }, {
        " ": [emitAttr, 2],
        ">": [emitAttr, emitNode(false), 0],
        "/": [emitAttr, 8],
        "": [attrVal]
      }, {
        ">": [emitNode(true), 0],
        "": [parseError("state 8: failed to properly close a /> tag"), 0]
      }, {
        ">": [closeNode, 0],
        "": [tagName]
      }, {
        "-": [11],
        "": [parseError("state 11: unknown <! tag"), 0]
      }, {
        "-": [12],
        "": [parseError("state 12: invalid <!-- tag"), 0]
      }, {
        "-": [13],
        "": [text, 12]
      }, {
        "-": [14],
        "": [
          (function() {
            return text.push('-');
          }), text, 12
        ]
      }, {
        ">": [emitComment, 0],
        "": [
          (function() {
            return text.push('--');
          }), text, 12
        ]
      }
    ];
    while (c = input[i++]) {
      m = states[mode];
      result = m[c] || m[""] || [];
      for (_i = 0, _len = result.length; _i < _len; _i++) {
        x = result[_i];
        if (x.call) {
          x();
        } else if (typeof x === "number") {
          mode = x;
        } else if (x.push) {
          x.push(c);
        }
      }
    }
    emitText();
    emitNode();
    return cursor;
  };

  entity_table = {
    "&": "&amp;",
    "™": "&#8482;",
    "€": "&euro;",
    " ": "&nbsp;",
    '"': "&quot;",
    "<": "&lt;",
    ">": "&gt;",
    "¡": "&iexcl;",
    "¢": "&cent;",
    "£": "&pound;",
    "¤": "&curren;",
    "¥": "&yen;",
    "¦": "&brvbar;",
    "§": "&sect;",
    "¨": "&uml;",
    "©": "&copy;",
    "ª": "&ordf;",
    "«": "&laquo;",
    "¬": "&not;",
    "¯": "&shy;",
    "®": "&reg;",
    "°": "&deg;",
    "±": "&plusmn;",
    "²": "&sup2;",
    "³": "&sup3;",
    "´": "&acute;",
    "µ": "&micro;",
    "¶": "&para;",
    "·": "&middot;",
    "¸": "&cedil;",
    "¹": "&sup1;",
    "º": "&ordm;",
    "»": "&raquo;",
    "¼": "&frac14;",
    "½": "&frac12;",
    "¾": "&frac34;",
    "¿": "&iquest;",
    "À": "&Agrave;",
    "Á": "&Aacute;",
    "Â": "&Acirc;",
    "Ã": "&Atilde;",
    "Ä": "&Auml;",
    "Å": "&Aring;",
    "Æ": "&AElig;",
    "Ç": "&Ccedil;",
    "È": "&Egrave;",
    "É": "&Eacute;",
    "Ê": "&Ecirc;",
    "Ë": "&Euml;",
    "Ì": "&Igrave;",
    "Í": "&Iacute;",
    "Î": "&Icirc;",
    "Ï": "&Iuml;",
    "Ð": "&ETH;",
    "Ñ": "&Ntilde;",
    "Ò": "&Ograve;",
    "Ó": "&Oacute;",
    "Ô": "&Ocirc;",
    "Õ": "&Otilde;",
    "Ö": "&Ouml;",
    "×": "&times;",
    "Ø": "&Oslash;",
    "Ù": "&Ugrave;",
    "Ú": "&Uacute;",
    "Û": "&Ucirc;",
    "Ü": "&Uuml;",
    "Ý": "&Yacute;",
    "Þ": "&THORN;",
    "ß": "&szlig;",
    "à": "&agrave;",
    "á": "&aacute;",
    "â": "&acirc;",
    "ã": "&atilde;",
    "ä": "&auml;",
    "å": "&aring;",
    "æ": "&aelig;",
    "ç": "&ccedil;",
    "è": "&egrave;",
    "é": "&eacute;",
    "ê": "&ecirc;",
    "ë": "&euml;",
    "ì": "&igrave;",
    "í": "&iacute;",
    "î": "&icirc;",
    "ï": "&iuml;",
    "ð": "&eth;",
    "ñ": "&ntilde;",
    "ò": "&ograve;",
    "ó": "&oacute;",
    "ô": "&ocirc;",
    "õ": "&otilde;",
    "ö": "&ouml;",
    "÷": "&divide;",
    "ø": "&oslash;",
    "ù": "&ugrave;",
    "ú": "&uacute;",
    "û": "&ucirc;",
    "ü": "&uuml;",
    "ý": "&yacute;",
    "þ": "&thorn;",
    "ÿ": "&#255;",
    "Ā": "&#256;",
    "ā": "&#257;",
    "Ă": "&#258;",
    "ă": "&#259;",
    "Ą": "&#260;",
    "ą": "&#261;",
    "Ć": "&#262;",
    "ć": "&#263;",
    "Ĉ": "&#264;",
    "ĉ": "&#265;",
    "Ċ": "&#266;",
    "ċ": "&#267;",
    "Č": "&#268;",
    "č": "&#269;",
    "Ď": "&#270;",
    "ď": "&#271;",
    "Đ": "&#272;",
    "đ": "&#273;",
    "Ē": "&#274;",
    "ē": "&#275;",
    "Ĕ": "&#276;",
    "ĕ": "&#277;",
    "Ė": "&#278;",
    "ė": "&#279;",
    "Ę": "&#280;",
    "ę": "&#281;",
    "Ě": "&#282;",
    "ě": "&#283;",
    "Ĝ": "&#284;",
    "ĝ": "&#285;",
    "Ğ": "&#286;",
    "ğ": "&#287;",
    "Ġ": "&#288;",
    "ġ": "&#289;",
    "Ģ": "&#290;",
    "ģ": "&#291;",
    "Ĥ": "&#292;",
    "ĥ": "&#293;",
    "Ħ": "&#294;",
    "ħ": "&#295;",
    "Ĩ": "&#296;",
    "ĩ": "&#297;",
    "Ī": "&#298;",
    "ī": "&#299;",
    "Ĭ": "&#300;",
    "ĭ": "&#301;",
    "Į": "&#302;",
    "į": "&#303;",
    "İ": "&#304;",
    "ı": "&#305;",
    "Ĳ": "&#306;",
    "ĳ": "&#307;",
    "Ĵ": "&#308;",
    "ĵ": "&#309;",
    "Ķ": "&#310;",
    "ķ": "&#311;",
    "ĸ": "&#312;",
    "Ĺ": "&#313;",
    "ĺ": "&#314;",
    "Ļ": "&#315;",
    "ļ": "&#316;",
    "Ľ": "&#317;",
    "ľ": "&#318;",
    "Ŀ": "&#319;",
    "ŀ": "&#320;",
    "Ł": "&#321;",
    "ł": "&#322;",
    "Ń": "&#323;",
    "ń": "&#324;",
    "Ņ": "&#325;",
    "ņ": "&#326;",
    "Ň": "&#327;",
    "ň": "&#328;",
    "ŉ": "&#329;",
    "Ŋ": "&#330;",
    "ŋ": "&#331;",
    "Ō": "&#332;",
    "ō": "&#333;",
    "Ŏ": "&#334;",
    "ŏ": "&#335;",
    "Ő": "&#336;",
    "ő": "&#337;",
    "Œ": "&#338;",
    "œ": "&#339;",
    "Ŕ": "&#340;",
    "ŕ": "&#341;",
    "Ŗ": "&#342;",
    "ŗ": "&#343;",
    "Ř": "&#344;",
    "ř": "&#345;",
    "Ś": "&#346;",
    "ś": "&#347;",
    "Ŝ": "&#348;",
    "ŝ": "&#349;",
    "Ş": "&#350;",
    "ş": "&#351;",
    "Š": "&#352;",
    "š": "&#353;",
    "Ţ": "&#354;",
    "ţ": "&#355;",
    "Ť": "&#356;",
    "ť": "&#357;",
    "Ŧ": "&#358;",
    "ŧ": "&#359;",
    "Ũ": "&#360;",
    "ũ": "&#361;",
    "Ū": "&#362;",
    "ū": "&#363;",
    "Ŭ": "&#364;",
    "ŭ": "&#365;",
    "Ů": "&#366;",
    "ů": "&#367;",
    "Ű": "&#368;",
    "ű": "&#369;",
    "Ų": "&#370;",
    "ų": "&#371;",
    "Ŵ": "&#372;",
    "ŵ": "&#373;",
    "Ŷ": "&#374;",
    "ŷ": "&#375;",
    "Ÿ": "&#376;",
    "Ź": "&#377;",
    "ź": "&#378;",
    "Ż": "&#379;",
    "ż": "&#380;",
    "Ž": "&#381;",
    "ž": "&#382;",
    "ſ": "&#383;"
  };

  escape = function(input) {
    var c;
    input = unescape(input);
    for (c in entity_table) {
      input = input.replace(c, entity_table[c]);
    }
    return input;
  };

  unescape = function(input) {
    var c;
    for (c in entity_table) {
      input = input.replace(entity_table[c], c);
    }
    return input;
  };

  if (privates) {
    privates.parse = parse;
    privates.escape = escape;
    privates.unescape = unescape;
  }

}).call(this);
/*
 * Copyright (C) 2007-2010 Diego Perini
 * All rights reserved.
 *
 * nwmatcher.js - A fast CSS selector engine and matcher
 *
 * Author: Diego Perini <diego.perini at gmail com>
 * Version: 1.2.4beta
 * Created: 20070722
 * Release: 20110116
 *
 * License:
 *  http://javascript.nwbox.com/NWMatcher/MIT-LICENSE
 * Download:
 *  http://javascript.nwbox.com/NWMatcher/nwmatcher.js
 */

privates.init = function(global, document) {

  // var version = 'nwmatcher-1.2.4beta',

  // processing context
  var doc = document,

  // context root element
  root = doc.documentElement,

  // save method reference
  slice = Array.prototype.slice,

  // persist last selector/matcher parsing data
  lastError = '',
  lastSlice = '',
  lastPosition = 0,
  lastMatcher = '',
  lastSelector = '',
  isSingleMatch = false,
  isSingleSelect = false,

  // initialize selector/matcher loading context
  lastMatchContext = doc,
  lastSelectContext = doc,

  // prefixes identifying id, class & pseudo-class
  prefixes = '[.:#]?',

  // attributes operators
  // ! invalid but compat !
  operators = '([~*^$|!]?={1})',

  // whitespace characters
  whitespace = '[\\x20\\t\\n\\r\\f]*',

  // 4 combinators F E, F>E, F+E, F~E
  combinators = '[\\x20]|[>+~][^>+~]',

  // an+b format params for psuedo-classes
  pseudoparms = '[-+]?\\d*n?[-+]?\\d*',

  // CSS quoted string values
  quotedvalue = '"[^"]*"' + "|'[^']*'",

  // http://www.w3.org/TR/css3-syntax/#characters
  // unicode/ISO 10646 characters 161 and higher
  // NOTE: Safari 2.0.x crashes with escaped (\\)
  // Unicode ranges in regular expressions so we
  // use a negated character range class instead
  encoding = '(?:[-\\w]|[^\\x00-\\xa0]|\\\\.)',

  // CSS identifier syntax
  identifier = '(?:-?[_a-zA-Z]{1}[-\\w]*|[^\\x00-\\xa0]+|\\\\.+)+',

  // build attribute string
  attributes =
    whitespace + '(' + encoding + '+:?' + encoding + '+)' +
    whitespace + '(?:' + operators + whitespace + '(' +
    quotedvalue + '|' + identifier + '))?' + whitespace,

  // build pseudoclass string
  pseudoclass = '((?:' +
    // an+b parameters or quoted string
    pseudoparms + '|' + quotedvalue + '|' +
    // id, class, pseudo-class selector
    prefixes + '|' + encoding + '+|' +
    // nested HTML attribute selector
    '\\[' + attributes + '\\]|' +
    // nested pseudo-class selector
    '\\(.+\\)|' + whitespace + '|' +
    // nested pseudos/separators
    ',)+)',

  // placeholder for extensions
  extensions = '.+',

  // CSS3: syntax scanner and
  // one pass validation only
  // using regular expression
  standardValidator =
    // discard start
    '(?=\s*[^>+~(){}<>])' +
    // open match group
    '(' +
    //universal selector
    '\\*' +
    // id/class/tag/pseudo-class identifier
    '|(?:' + prefixes + identifier + ')' +
    // combinator selector
    '|' + combinators +
    // HTML attribute selector
    '|\\[' + attributes + '\\]' +
    // pseudo-classes parameters
    '|\\(' + pseudoclass + '\\)' +
    // dom properties selector (extension)
    '|\\{' + extensions + '\\}' +
    // selector group separator (comma)
    '|,' +
    // close match group
    ')+',

  // validator for standard selectors as default
  reValidator = new RegExp(standardValidator, 'g'),

  // validator for complex selectors in ':not()' pseudo-classes
  extendedValidator = standardValidator.replace(pseudoclass, '.*'),

  // whitespace is any combination of these 5 character [\x20\t\n\r\f]
  // http://www.w3.org/TR/css3-selectors/#selector-syntax
  reTrimSpaces = new RegExp('^' +
    whitespace + '|' + whitespace + '$', 'g'),

  // only allow simple selectors nested in ':not()' pseudo-classes
  reSimpleNot = new RegExp('^(' +
    '(?!:not)' +
    '(' + prefixes +
    '|' + identifier +
    '|\\([^()]*\\))+' +
    '|\\[' + attributes + '\\]' +
    ')$'),

  // skip group of round brackets
  skipround = '\\([^()]+\\)|\\(.*\\)',
  // skip group of curly brackets
  skipcurly = '\\{[^{}]+\\}|\\{.*\\}',
  // skip group of square brackets
  skipsquare = '\\[[^[\\]]*\\]|\\[.*\\]',

  // skip [ ], ( ), { } groups in token tails
  skipgroup = '\\[.*\\]|\\(.*\\)|\\{.*\\}',

  // split comma groups, exclude commas from
  // quotes '' "" and from brackets () [] {}
  reSplitGroup = new RegExp('(' +
    '[^(,)\\\\\\[\\]]+' +
    '|\\[(?:' + skipsquare +
    '|' + quotedvalue +
    '|[^\\[\\]]+)+\\]' +
    '|' + skipround +
    '|' + skipcurly +
    '|\\\\.' +
    ')+', 'g'),

  // split last, right most, selector group token
  reSplitToken = new RegExp('(' +
    '\\(' + pseudoclass + '\\)|' +
    '\\[' + attributes + '\\]|' +
    '[^\x20>+~]|\\\\.)+', 'g'),

  // for pseudos, ids and in excess whitespace removal
  reClassValue = new RegExp('(' + identifier + ')'),
  // reIdSelector = new RegExp('#(' + identifier + ')'),
  reWhiteSpace = /[\x20\t\n\r\f]+/g,

  // match missing R/L context
  reLeftContext = /^\s*[>+~]{1}/,
  reRightContext = /[>+~]{1}\s*$/,

  reOptimizeSelector = new RegExp(identifier + '|^$'),

  /*----------------------------- FEATURE TESTING ----------------------------*/

  // detect native methods
  isNative = (function() {
    var s = (global.toString + '').replace(/toString/g, '');
    return function(object, method) {
      var m = object && object[method], r = new RegExp(method, 'g');
      return m && typeof m != 'string' && s == (m + '').replace(r, '');
    };
  })(),

  // Safari 2 missing document.compatMode property
  // makes harder to detect Quirks vs. Strict mode
  isQuirks =
    function(document) {
      return typeof document.compatMode == 'string' ?
        document.compatMode.indexOf('CSS') < 0 :
        (function() {
          var div = document.createElement('div'),
            isStrict = div.style &&
              (div.style.width = 1) &&
              div.style.width != '1px';
          div = null;
          return !isStrict;
        })();
    },

  // XML is functional in W3C browsers
  isXML = 'xmlVersion' in doc ?
    function(document) {
      return !!document.xmlVersion ||
        (/xml$/).test(document.contentType) ||
        !(/html/i).test(document.documentElement.nodeName);
    } :
    function(document) {
      return document.firstChild.nodeType == 7 &&
        (/xml/i).test(document.firstChild.nodeName) ||
        !(/html/i).test(document.documentElement.nodeName);
    },

  // initialized with the loading context
  // and reset for each selection query
  isQuirksMode = isQuirks(doc),
  isXMLDocument = isXML(doc),

  // NATIVE_XXXXX true if method exist and is callable
  // detect if DOM methods are native in browsers
  NATIVE_FOCUS = isNative(doc, 'hasFocus'),
  NATIVE_QSAPI = isNative(doc, 'querySelector'),
  NATIVE_GEBID = isNative(doc, 'getElementById'),
  NATIVE_GEBTN = isNative(root, 'getElementsByTagName'),
  NATIVE_GEBCN = isNative(root, 'getElementsByClassName'),

  // detect native getAttribute/hasAttribute methods,
  // frameworks extend these to elements, but it seems
  // this does not work for XML namespaced attributes,
  // used to check both getAttribute/hasAttribute in IE
  NATIVE_GET_ATTRIBUTE = isNative(root, 'getAttribute'),
  NATIVE_HAS_ATTRIBUTE = isNative(root, 'hasAttribute'),

  // check if slice() can convert nodelist to array
  // see http://yura.thinkweb2.com/cft/
  NATIVE_SLICE_PROTO =
    (function() {
      var isBuggy = false, id = root.id;
      root.id = 'length';
      try {
        isBuggy = !!slice.call(doc.childNodes, 0)[0];
      } catch(e) { }
      root.id = id;
      return isBuggy;
    })(),

  // supports the new traversal API
  NATIVE_TRAVERSAL_API =
    'nextElementSibling' in root && 'previousElementSibling' in root,

  // select Matches Selector API to use if available
  NATIVE_MATCHES_SELECTOR =
    isNative(root, 'matchesSelector') ? 'matchesSelector' :
    isNative(root, 'msMatchesSelector') ? 'msMatchesSelector' :
    isNative(root, 'mozMatchesSelector') ? 'mozMatchesSelector' :
    isNative(root, 'webkitMatchesSelector') ? 'webkitMatchesSelector' : null,

  // BUGGY_XXXXX true if method is feature tested and has known bugs
  // detect buggy gEBID
  BUGGY_GEBID = NATIVE_GEBID ?
    (function() {
      var isBuggy = true, x = 'x' + String(+new Date),
        a = doc.createElementNS ? 'a' : '<a name="' + x + '">';
      (a = doc.createElement(a)).name = x;
      root.insertBefore(a, root.firstChild);
      isBuggy = !!doc.getElementById(x);
      root.removeChild(a);
      a = null;
      return isBuggy;
    })() :
    true,

  // detect IE gEBTN comment nodes bug
  BUGGY_GEBTN = NATIVE_GEBTN ?
    (function() {
      var isBuggy, div = doc.createElement('div');
      div.appendChild(doc.createComment(''));
      isBuggy = div.getElementsByTagName('*')[0];
      div.removeChild(div.firstChild);
      div = null;
      return !!isBuggy;
    })() :
    true,

  // detect Opera gEBCN second class and/or UTF8 bugs as well as Safari 3.2
  // caching class name results and not detecting when changed,
  // tests are based on the jQuery selector test suite
  BUGGY_GEBCN = NATIVE_GEBCN ?
    (function() {
      var isBuggy, div = doc.createElement('div'), test = '\u53f0\u5317';

      // Opera tests
      div.appendChild(doc.createElement('span')).
        setAttribute('class', test + 'abc ' + test);
      div.appendChild(doc.createElement('span')).
        setAttribute('class', 'x');

      isBuggy = !div.getElementsByClassName(test)[0];

      // Safari test
      div.lastChild.className = test;
      if (!isBuggy)
        isBuggy = div.getElementsByClassName(test).length !== 2;

      div.removeChild(div.firstChild);
      div.removeChild(div.firstChild);
      div = null;
      return isBuggy;
    })() :
    true,

  // detect IE bug with dynamic attributes
  BUGGY_GET_ATTRIBUTE = NATIVE_GET_ATTRIBUTE ?
    (function() {
      var isBuggy, input;
      (input = doc.createElement('input')).setAttribute('value', '5');
      return isBuggy = input.defaultValue != 5;
    })() :
    true,

  // detect IE bug with non-standard boolean attributes
  BUGGY_HAS_ATTRIBUTE = NATIVE_HAS_ATTRIBUTE ?
    (function() {
      var isBuggy, option = doc.createElement('option');
      option.setAttribute('selected', 'selected');
      isBuggy = !option.hasAttribute('selected');
      return isBuggy;
    })() :
    true,

  // detect matchesSelector correctly throw errors
  BUGGY_PSEUDOS = NATIVE_MATCHES_SELECTOR ?
    (function() {
      var isBuggy = false;
      try {
        root[NATIVE_MATCHES_SELECTOR](':buggy');
        isBuggy = true;
      } catch(e) { }
      return isBuggy;
    })() :
    true,

  // detect Safari bug with selected option elements
  BUGGY_SELECTED =
    (function() {
      var isBuggy, select = doc.createElement('select');
      select.appendChild(doc.createElement('option'));
      isBuggy = !select.firstChild.selected;
      return isBuggy;
    })(),

  // check Seletor API implementations
  RE_BUGGY_QSAPI = NATIVE_QSAPI ?
    (function() {
      var pattern = [ ], div = doc.createElement('div'), element;

      // In quirks mode css class names are case insensitive.
      // In standards mode they are case sensitive. See docs:
      // https://developer.mozilla.org/en/Mozilla_Quirks_Mode_Behavior
      // http://www.whatwg.org/specs/web-apps/current-work/#selectors

      // Safari 3.2 QSA doesn't work with mixedcase in quirksmode
      // https://bugs.webkit.org/show_bug.cgi?id=19047
      // must test the attribute selector '[class~=xxx]'
      // before '.xXx' or the bug may not present itself
      div.appendChild(doc.createElement('p')).setAttribute('class', 'xXx');
      div.appendChild(doc.createElement('p')).setAttribute('class', 'xxx');
      if (isQuirks(doc) &&
        (div.querySelectorAll('[class~=xxx]').length != 2 ||
        div.querySelectorAll('.xXx').length != 2)) {
        pattern.push('(?:\\[[\\x20\\t\\n\\r\\f]*class\\b|\\.' + identifier + ')');
      }
      div.removeChild(div.firstChild);
      div.removeChild(div.firstChild);

      // ^= $= *= operators bugs whith empty values (Opera 10 / IE8)
      div.appendChild(doc.createElement('p')).setAttribute('class', '');
      try {
        div.querySelectorAll('[class^=""]').length == 1 &&
          pattern.push('[*^$]=\\s*(?:""|' + "'')");
      } catch(e) { }
      div.removeChild(div.firstChild);

      // :checked bugs whith checkbox elements (Opera 10 to 10.53)
      element = doc.createElement('input');
      element.setAttribute('type', 'checkbox');
      element.setAttribute('checked', 'checked');
      div.appendChild(element);
      try {
        div.querySelectorAll(':checked').length == 1 ||
          pattern.push(':checked');
      } catch(e) { }
      div.removeChild(div.firstChild);

      // :checked bug with option elements (Firefox 3.6.x)
      // it wrongly includes 'selected' options elements
      element = doc.createElement('option');
      element.setAttribute('selected', 'selected');
      div.appendChild(element);
      try {
        div.querySelectorAll(':checked').length == 1 &&
          pattern.push(':checked');
      } catch(e) { }
      div.removeChild(div.firstChild);

      // :enabled :disabled bugs with hidden fields (Firefox 3.5 QSA bug)
      // http://www.w3.org/TR/html5/interactive-elements.html#selector-enabled
      // IE8 QSA has problems too and throws error with these dynamic pseudos
      (element = doc.createElement('input')).setAttribute('type', 'hidden');
      div.appendChild(element);
      try {
        div.querySelectorAll(':enabled').length === 1 &&
          pattern.push(':enabled', ':disabled');
      } catch(e) { }
      div.removeChild(div.firstChild);

      // :link bugs with hyperlinks matching (Firefox/Safari)
      div.appendChild(doc.createElement('a')).setAttribute('href', 'x');
      div.querySelectorAll(':link').length !== 1 && pattern.push(':link');
      div.removeChild(div.firstChild);

      // avoid attribute selectors for IE QSA
      if (BUGGY_HAS_ATTRIBUTE) {
        // IE fails in reading:
        // - original values for input/textarea
        // - original boolean values for controls
        pattern.push('\\[\\s*(?:checked|disabled|ismap|multiple|readonly|selected|value)');
      }

      div = null;
      return pattern.length ?
        new RegExp(pattern.join('|')) :
        { 'test': function() { return false; } };
    })() :
    true,

  // matches pseudo-classes
  RE_PSEUDOS = new RegExp(':[-\\w]+'),

  // matches simple id, tag & class selectors
  RE_SIMPLE_SELECTOR = new RegExp(
    !(BUGGY_GEBTN && BUGGY_GEBCN) ?
      '^(?:\\*|[.#]?-?[_a-zA-Z]{1}' + encoding + '*)$' :
      '^#?-?[_a-zA-Z]{1}' + encoding + '*$'),

  /*----------------------------- LOOKUP OBJECTS -----------------------------*/

  LINK_NODES = { 'a': 1, 'A': 1, 'area': 1, 'AREA': 1, 'link': 1, 'LINK': 1 },

  QSA_NODE_TYPES = { '9': 1, '11': 1 },

  // boolean attributes should return attribute name instead of true/false
  ATTR_BOOLEAN = {
    checked: 1, disabled: 1, ismap: 1, multiple: 1, readonly: 1, selected: 1
  },

  // dynamic attributes that needs to be checked against original HTML value
  ATTR_DEFAULT = {
    value: 'defaultValue',
    checked: 'defaultChecked',
    selected: 'defaultSelected'
  },

  // HTML to DOM namespace mapping for special case attributes (IE engines)
  ATTR_MAPPING = {
    'class': 'className', 'for': 'htmlFor'
  },

  // attribute referencing URI data values need special treatment in IE
  ATTR_URIDATA = {
    'action': 2, 'cite': 2, 'codebase': 2, 'data': 2, 'href': 2,
    'longdesc': 2, 'lowsrc': 2, 'src': 2, 'usemap': 2
  },

  // HTML 5 draft specifications
  // http://www.whatwg.org/specs/web-apps/current-work/#selectors
  HTML_TABLE = {
    // class attribute must be treated case-insensitive in HTML quirks mode
    // initialized by default to Standard Mode (case-sensitive),
    // set dynamically by the attribute resolver
    'class': 0,
    'accept': 1, 'accept-charset': 1, 'align': 1, 'alink': 1, 'axis': 1,
    'bgcolor': 1, 'charset': 1, 'checked': 1, 'clear': 1, 'codetype': 1, 'color': 1,
    'compact': 1, 'declare': 1, 'defer': 1, 'dir': 1, 'direction': 1, 'disabled': 1,
    'enctype': 1, 'face': 1, 'frame': 1, 'hreflang': 1, 'http-equiv': 1, 'lang': 1,
    'language': 1, 'link': 1, 'media': 1, 'method': 1, 'multiple': 1, 'nohref': 1,
    'noresize': 1, 'noshade': 1, 'nowrap': 1, 'readonly': 1, 'rel': 1, 'rev': 1,
    'rules': 1, 'scope': 1, 'scrolling': 1, 'selected': 1, 'shape': 1, 'target': 1,
    'text': 1, 'type': 1, 'valign': 1, 'valuetype': 1, 'vlink': 1
  },

  // the following attributes must be treated case-insensitive in XHTML mode
  // Niels Leenheer http://rakaz.nl/item/css_selector_bugs_case_sensitivity
  XHTML_TABLE = {
    'accept': 1, 'accept-charset': 1, 'alink': 1, 'axis': 1,
    'bgcolor': 1, 'charset': 1, 'codetype': 1, 'color': 1,
    'enctype': 1, 'face': 1, 'hreflang': 1, 'http-equiv': 1,
    'lang': 1, 'language': 1, 'link': 1, 'media': 1, 'rel': 1,
    'rev': 1, 'target': 1, 'text': 1, 'type': 1, 'vlink': 1
  },

  /*-------------------------- REGULAR EXPRESSIONS ---------------------------*/

  // placeholder to add functionalities
  Selectors = {
    // as a simple example this will check
    // for chars not in standard ascii table
    //
    // 'mySpecialSelector': {
    //  'Expression': /\u0080-\uffff/,
    //  'Callback': mySelectorCallback
    // }
    //
    // 'mySelectorCallback' will be invoked
    // only after passing all other standard
    // checks and only if none of them worked
  },

  // attribute operators
  Operators = {
     '=': "n=='%m'",
    '^=': "n.indexOf('%m')==0",
    '*=': "n.indexOf('%m')>-1",
    '|=': "(n+'-').indexOf('%m-')==0",
    '~=': "(' '+n+' ').indexOf(' %m ')>-1",
    '$=': "n.substr(n.length-'%m'.length)=='%m'"
  },

  // optimization expressions
  Optimize = {
    ID: new RegExp('^\\*?#(' + encoding + '+)|' + skipgroup),
    TAG: new RegExp('^(' + encoding + '+)|' + skipgroup),
    CLASS: new RegExp('^\\*?\\.(' + encoding + '+$)|' + skipgroup),
    NAME: /\[\s*name\s*=\s*((["']*)([^'"()]*?)\2)?\s*\]/
  },

  // precompiled Regular Expressions
  Patterns = {
    // structural pseudo-classes and child selectors
    spseudos: /^\:(root|empty|nth)?-?(first|last|only)?-?(child)?-?(of-type)?(?:\(([^\x29]*)\))?(.*)/,
    // uistates + dynamic + negation pseudo-classes
    dpseudos: /^\:([\w]+|[^\x00-\xa0]+)(?:\((["']*)(.*?(\(.*\))?[^'"()]*?)\2\))?(.*)/,
    // element attribute matcher
    attribute: new RegExp('^\\[' + attributes + '\\](.*)'),
    // E > F
    children: /^[\x20\t\n\r\f]*\>[\x20\t\n\r\f]*(.*)/,
    // E + F
    adjacent: /^[\x20\t\n\r\f]*\+[\x20\t\n\r\f]*(.*)/,
    // E ~ F
    relative: /^[\x20\t\n\r\f]*\~[\x20\t\n\r\f]*(.*)/,
    // E F
    ancestor: /^[\x20\t\n\r\f]+(.*)/,
    // all
    universal: /^\*(.*)/,
    // id
    id: new RegExp('^#(' + encoding + '+)(.*)'),
    // tag
    tagName: new RegExp('^(' + encoding + '+)(.*)'),
    // class
    className: new RegExp('^\\.(' + encoding + '+)(.*)')
  },

  // current CSS3 grouping of Pseudo-Classes
  // they allow implementing extensions
  // and improve error notifications;
  // the assigned value represent current spec status:
  // 3 = CSS3, 2 = CSS2, '?' = maybe implemented
  CSS3PseudoClasses = {
    Structural: {
      'root': 3, 'empty': 3,
      'nth-child': 3, 'nth-last-child': 3,
      'nth-of-type': 3, 'nth-last-of-type': 3,
      'first-child': 3, 'last-child': 3, 'only-child': 3,
      'first-of-type': 3, 'last-of-type': 3, 'only-of-type': 3
    },
    Others: {
      'link': 3, 'visited': 3,
      'target': 3, 'lang': 3, 'not': 3,
      'active': 3, 'focus': 3, 'hover': 3,
      'checked': 3, 'disabled': 3, 'enabled': 3, 'selected': 2
    }
  },

  /*------------------------------ DOM METHODS -------------------------------*/

  // concat elements to data
  concatList =
    function(data, elements) {
      var i = -1, element;
      if (data.length === 0 && Array.slice)
        return Array.slice(elements);
      while ((element = elements[++i]))
        data[data.length] = element;
      return data;
    },

  // concat elements to data and callback
  concatCall =
    function(data, elements, callback) {
      var i = -1, element;
      while ((element = elements[++i]))
        callback(data[data.length] = element);
      return data;
    },

  // element by id (raw)
  byIdRaw =
    function(id, elements) {
      var i = -1, element = null;
      while ((element = elements[++i])) {
        if (element.getAttribute('id') == id) {
          break;
        }
      }
      return element;
    },

  // element by id
  // @return element reference or null
  byId = !BUGGY_GEBID ?
    function(id, from) {
      from || (from = doc);
      id = id.replace(/\\/g, '');
      if (isXMLDocument || from.nodeType != 9) {
        return byIdRaw(id, from.getElementsByTagName('*'));
      }
      return from.getElementById(id);
    } :
    function(id, from) {
      var element = null;
      from || (from = doc);
      id = id.replace(/\\/g, '');
      if (isXMLDocument || from.nodeType != 9) {
        return byIdRaw(id, from.getElementsByTagName('*'));
      }
      if ((element = from.getElementById(id)) &&
        element.name == id && from.getElementsByName) {
        return byIdRaw(id, from.getElementsByName(id));
      }
      return element;
    },

  // elements by tag (raw)
  // @return array
  byTagRaw = function(tag, from) {
    var any = tag == '*', element = from, elements = [ ], next = element.firstChild;
    any || (tag = tag.toUpperCase());
    while ((element = next)) {
      if (element.tagName > '@' && (any || element.tagName.toUpperCase() == tag)) {
        elements[elements.length] = element;
      }
      if ((next = element.firstChild || element.nextSibling)) continue;
      while (!next && (element = element.parentNode) && element != from) {
        next = element.nextSibling;
      }
    }
    return elements;
  },

  // elements by tag
  // @return array
  byTag = !BUGGY_GEBTN && NATIVE_SLICE_PROTO ?
    function(tag, from) {
      from || (from = doc);
      return slice.call(from.getElementsByTagName ?
        from.getElementsByTagName(tag) :
        byTagRaw(tag, from), 0);
    } :
    function(tag, from) {
      var j, i = j = -1, data = [ ],
        element, elements = (from || doc).getElementsByTagName(tag);
      if (tag == '*') {
        while ((element = elements[++i])) {
          if (element.nodeName > '@')
            data[++j] = element;
        }
      } else {
        while ((element = elements[++i])) {
          data[i] = element;
        }
      }
      return data;
    },

  // elements by name
  // @return array
  byName =
    function(name, from) {
      return select('[name="' + name.replace(/\\/g, '') + '"]', from || doc);
    },

  // elements by class
  // @return array
  byClass = !BUGGY_GEBCN && NATIVE_SLICE_PROTO ?
    function(className, from) {
      return slice.call((from || doc).
        getElementsByClassName(className.replace(/\\/g, '')), 0);
    } :
    function(className, from) {
      from || (from = doc);
      var i = -1, j = i,
        data = [ ], element,
        elements = byTag('*', from),
        host = from.ownerDocument || from,
        quirks = isQuirks(host), xml = isXML(host),
        n = quirks ? className.toLowerCase() : className;
      className = ' ' + n.replace(/\\/g, '') + ' ';
      while ((element = elements[++i])) {
        n = xml ? element.getAttribute('class') : element.className;
        if (n && n.length && (' ' + (quirks ? n.toLowerCase() : n).
          replace(reWhiteSpace, ' ') + ' ').indexOf(className) > -1) {
          data[++j] = element;
        }
      }
      return data;
    },

  // check if an element is a descendant of container
  contains = 'compareDocumentPosition' in root ?
    function(container, element) {
      return (container.compareDocumentPosition(element) & 16) == 16;
    } : 'contains' in root ?
    function(container, element) {
      return container !== element && container.contains(element);
    } :
    function(container, element) {
      while ((element = element.parentNode)) {
        if (element === container) return true;
      }
      return false;
    },

  // attribute value
  // @return string
  getAttribute = !BUGGY_GET_ATTRIBUTE ?
    function(node, attribute) {
      return node.getAttribute(attribute) || '';
    } :
    function(node, attribute) {
      attribute = attribute.toLowerCase();
      if (ATTR_DEFAULT[attribute] in node) {
        return node[ATTR_DEFAULT[attribute]] || '';
      }
      return (
        // specific URI data attributes (parameter 2 to fix IE bug)
        ATTR_URIDATA[attribute] ? node.getAttribute(attribute, 2) || '' :
        // boolean attributes should return name instead of true/false
        ATTR_BOOLEAN[attribute] ? node.getAttribute(attribute) ? attribute : '' :
          ((node = node.getAttributeNode(attribute)) && node.value) || '');
    },

  // attribute presence
  // @return boolean
  hasAttribute = !BUGGY_HAS_ATTRIBUTE ?
    function(node, attribute) {
      return node.hasAttribute(attribute);
    } :
    function(node, attribute) {
      attribute = attribute.toLowerCase();
      // older IE engines requires DOM mapping
      // see NetFront/Playstation as an example
      attribute = attribute in ATTR_MAPPING ?
        ATTR_MAPPING[attribute] : attribute;
      if (ATTR_DEFAULT[attribute] in node) {
        return !!node[ATTR_DEFAULT[attribute]];
      }
      // need to get at AttributeNode first on IE
      node = node.getAttributeNode(attribute);
      // use both "specified" & "nodeValue" properties
      return !!(node && (node.specified || node.nodeValue));
    },

  // check node emptyness
  isEmpty =
    function(node) {
      node = node.firstChild;
      while (node) {
        if (node.nodeType == 3 || node.nodeName > '@') return false;
        node = node.nextSibling;
      }
      return true;
    },

  // check if element matches the :link pseudo
  // @return boolean
  isLink =
    function(element) {
      return hasAttribute(element,'href') && LINK_NODES[element.nodeName];
    },

  // child position by nodeType
  // @return number
  nthElement =
    function(element, last) {
      var count = 1, succ = last ? 'nextSibling' : 'previousSibling';
      while ((element = element[succ])) {
        if (element.nodeName > '@') ++count;
      }
      return count;
    },

  // child position by nodeName
  // @return number
  nthOfType =
    function(element, last) {
      var count = 1, succ = last ? 'nextSibling' : 'previousSibling', type = element.nodeName;
      while ((element = element[succ])) {
        if (element.nodeName == type) ++count;
      }
      return count;
    },

  /*------------------------------- DEBUGGING --------------------------------*/

  // compile selectors to ad-hoc functions resolvers
  // @selector string
  // @mode boolean
  // false = select resolvers
  // true = match resolvers
  compile =
    function(selector, mode) {
      return compileGroup(selector, '', mode || false);
    },

  // set working mode
  configure =
    function(options) {
      for (var i in options) {
        if (i == 'VERBOSITY') {
          VERBOSITY = !!options[i];
        } else if (i == 'SIMPLENOT') {
          SIMPLENOT = !!options[i];
          HTMLResolvers = { };
          XMLResolvers = { };
          HTMLMatchers = { };
          XMLMatchers = { };
          USE_QSAPI = false;
          reValidator = new RegExp(extendedValidator, 'g');
        } else if (i == 'SHORTCUTS') {
          SHORTCUTS = !!options[i];
        } else if (i == 'USE_QSAPI') {
          USE_QSAPI = !!options[i] && NATIVE_QSAPI;
          reValidator = new RegExp(standardValidator, 'g');
        }
      }
    },

  // control user notifications
  emit =
    function(message) {
			var console, err;
      if (VERBOSITY) {
        // FF/Safari/Opera DOMException.SYNTAX_ERR = 12
        if (typeof global.DOMException !== 'undefined') {
          err = new Error();
          err.message = 'SYNTAX_ERR: (Selectors) ' + message;
          err.code = 12;
          throw err;
        } else {
          throw new Error(12, 'SYNTAX_ERR: (Selectors) ' + message);
        }
      } else {
        console = global.console;
        if (console && console.log) {
          console.log(message);
        } else {
          if (/exception/i.test(message)) {
            global.status = message;
            global.defaultStatus = message;
          } else {
            global.status += message;
          }
        }
      }
    },

  // by default disable complex selectors nested in
  // ':not()' pseudo-classes, as for specifications
  SIMPLENOT = true,

  // by default do not add missing left/right context
  // to selector string shortcuts like "+div" or "ul>"
  SHORTCUTS = false,

  // controls the engine error/warning notifications
  VERBOSITY = true,

  // controls enabling the Query Selector API branch
  USE_QSAPI = NATIVE_QSAPI,

  /*---------------------------- COMPILER METHODS ----------------------------*/

  // do not change this, it is searched & replaced
  // in multiple places to build compiled functions
  ACCEPT_NODE = 'f&&f(c[k]);r[r.length]=c[k];continue main;',

  // checks if nodeName comparisons need to be uppercased
  TO_UPPER_CASE = doc.createElement('nAv').nodeName == 'nAv' ?
    '.toUpperCase()' : '',

  // compile a comma separated group of selector
  // @mode boolean true for select, false for match
  // return a compiled function
  compileGroup = function(selector, source, mode) {

      var i = -1, seen = { }, token,
        parts = typeof selector == 'string' ?
          selector.match(reSplitGroup) : selector;

      // for each selector in the group
      while ((token = parts[++i])) {
        token = token.replace(reTrimSpaces, '');
        // avoid repeating the same token
        // in comma separated group (p, p)
        if (!seen[token]) {
          seen[token] = true;
          source += (i > 0 ? (mode ? 'e=c[k];': 'e=k;') : '') +
            compileSelector(token, mode ? ACCEPT_NODE : 'f&&f(k);return true;');
        }
      }

      if (mode) {
        // for select method
        return new Function('c,s,r,d,h,g,f',
          'var N,n,x=0,k=-1,e;main:while((e=c[++k])){' + source + '}return r;');
      } else {
        // for match method
        return new Function('e,s,r,d,h,g,f',
          'var N,n,x=0,k=e;' + source + 'return false;');
      }
    },

  // compile a CSS3 string selector into ad-hoc javascript matching function
  // @return string (to be compiled)
  compileSelector = function(selector, source) {

      var i, a, b, n, k, expr, match, result, status, test, type;

      k = 0;

      while (selector) {

        // *** Universal selector
        // * match all (empty block, do not remove)
        if ((match = selector.match(Patterns.universal))) {
          // do nothing, handled in the compiler where
          // BUGGY_GEBTN return comment nodes (ex: IE)
          i = true;
        }

        // *** ID selector
        // #Foo Id case sensitive
        else if ((match = selector.match(Patterns.id))) {
          // document can contain conflicting elements (id/name)
          // prototype selector unit need this method to recover bad HTML forms
          source = 'if(' + (isXMLDocument ?
            's.getAttribute(e,"id")' :
            '(e.submit?s.getAttribute(e,"id"):e.id)') +
            '=="' + match[1] + '"' +
            '){' + source + '}';
        }

        // *** Type selector
        // Foo Tag (case insensitive)
        else if ((match = selector.match(Patterns.tagName))) {
          // both tagName and nodeName properties may be upper/lower case
          // depending on their creation NAMESPACE in createElementNS()
          source = 'if(e.nodeName' + (isXMLDocument ?
            '=="' + match[1] + '"' : TO_UPPER_CASE +
            '=="' + match[1].toUpperCase() + '"') +
            '){' + source + '}';
        }

        // *** Class selector
        // .Foo Class (case sensitive)
        else if ((match = selector.match(Patterns.className))) {
          // W3C CSS3 specs: element whose "class" attribute has been assigned a
          // list of whitespace-separated values, see section 6.4 Class selectors
          // and notes at the bottom; explicitly non-normative in this specification.
          source = 'if((n=' + (isXMLDocument ?
            's.getAttribute(e,"class")' : 'e.className') +
            ')&&n.length&&(" "+' + (isQuirksMode ? 'n.toLowerCase()' : 'n') +
            '.replace(' + reWhiteSpace + '," ")+" ").indexOf(" ' +
            (isQuirksMode ? match[1].toLowerCase() : match[1]) + ' ")>-1' +
            '){' + source + '}';
        }

        // *** Attribute selector
        // [attr] [attr=value] [attr="value"] [attr='value'] and !=, *=, ~=, |=, ^=, $=
        // case sensitivity is treated differently depending on the document type (see map)
        else if ((match = selector.match(Patterns.attribute))) {
          if (match[3]) match[3] = match[3].replace(/^\x22|\x22$/g, '').replace(/^\x27|\x27$/g, '');

          // xml namespaced attribute ?
          expr = match[1].split(':');
          expr = expr.length == 2 ? expr[1] : expr[0] + '';

          if (match[2] && !Operators[match[2]]) {
            emit('Unsupported operator in attribute selectors "' + selector + '"');
            return '';
          }

          // replace Operators parameter if needed
          if (match[2] && match[3] && (type = Operators[match[2]])) {
            // case treatment depends on document
            HTML_TABLE['class'] = isQuirksMode ? 1 : 0;
            // replace escaped values and HTML entities
            match[3] = match[3].replace(/\\([0-9a-f]{2,2})/, '\\x$1');
            test = (isXMLDocument ? XHTML_TABLE : HTML_TABLE)[expr.toLowerCase()];
            type = type.replace(/\%m/g, test ? match[3].toLowerCase() : match[3]);
          } else {
            test = false;
            // handle empty values
            type = match[2] == '=' ? 'n==""' : 'false';
          }

          // build expression for has/getAttribute
          expr = 'n=s.' + (match[2] ? 'get' : 'has') +
            'Attribute(e,"' + match[1] + '")' +
            (test ? '.toLowerCase();' : ';');

          source = expr + 'if(' + (match[2] ? type : 'n') + '){' + source + '}';
        }

        // *** Adjacent sibling combinator
        // E + F (F adiacent sibling of E)
        else if ((match = selector.match(Patterns.adjacent))) {
          k++;
          source = NATIVE_TRAVERSAL_API ?
            'var N' + k + '=e;if(e&&(e=e.previousElementSibling)){' + source + '}e=N' + k + ';' :
            'var N' + k + '=e;while(e&&(e=e.previousSibling)){if(e.nodeName>"@"){' + source + 'break;}}e=N' + k + ';';
        }

        // *** General sibling combinator
        // E ~ F (F relative sibling of E)
        else if ((match = selector.match(Patterns.relative))) {
          k++;
          source = NATIVE_TRAVERSAL_API ?
            ('var N' + k + '=e;e=e.parentNode.firstElementChild;' +
            'while(e&&e!=N' + k + '){' + source + 'e=e.nextElementSibling;}e=N' + k + ';') :
            ('var N' + k + '=e;e=e.parentNode.firstChild;' +
            'while(e&&e!=N' + k + '){if(e.nodeName>"@"){' + source + '}e=e.nextSibling;}e=N' + k + ';');
        }

        // *** Child combinator
        // E > F (F children of E)
        else if ((match = selector.match(Patterns.children))) {
          k++;
          source = 'var N' + k + '=e;if(e&&e!==h&&e!==g&&(e=e.parentNode)){' + source + '}e=N' + k + ';';
        }

        // *** Descendant combinator
        // E F (E ancestor of F)
        else if ((match = selector.match(Patterns.ancestor))) {
          k++;
          source = 'var N' + k + '=e;while(e&&e!==h&&e!==g&&(e=e.parentNode)){' + source + '}e=N' + k + ';';
        }

        // *** Structural pseudo-classes
        // :root, :empty,
        // :first-child, :last-child, :only-child,
        // :first-of-type, :last-of-type, :only-of-type,
        // :nth-child(), :nth-last-child(), :nth-of-type(), :nth-last-of-type()
        else if ((match = selector.match(Patterns.spseudos)) &&
          CSS3PseudoClasses.Structural[selector.match(reClassValue)[0]]) {

          switch (match[1]) {
            case 'root':
              // element root of the document
              if (match[6]) {
                source = 'if(s.contains(e.ownerDocument.documentElement,e)){' + source + '}';
              } else {
                source = 'if(e===h){' + source + '}';
              }
              break;

            case 'empty':
              // element that has no children
              source = 'if(s.isEmpty(e)){' + source + '}';
              break;

            default:
              if (match[1] && match[5]) {
                if (match[5] == 'n') {
                  source = 'if(e!==h){' + source + '}';
                  break;
                } else if (match[5] == 'even') {
                  a = 2;
                  b = 0;
                } else if (match[5] == 'odd') {
                  a = 2;
                  b = 1;
                } else {
                  // assumes correct "an+b" format, "b" before "a" to keep "n" values
                  b = ((n = match[5].match(/(-?\d+)$/)) ? parseInt(n[1], 10) : 0);
                  a = ((n = match[5].match(/(-?\d*)n/)) ? parseInt(n[1], 10) : 0);
                  if (n && n[1] == '-') a = -1;
                }

                // build test expression out of structural pseudo (an+b) parameters
                // see here: http://www.w3.org/TR/css3-selectors/#nth-child-pseudo
                test =  b < 1 && a > 1 ? '(n-(' + b + '))%' + a + '==0' : a > +1 ?
                  (match[2] == 'last') ? '(n-(' + b + '))%' + a + '==0' :
                  'n>=' + b + '&&(n-(' + b + '))%' + a + '==0' : a < -1 ?
                  (match[2] == 'last') ? '(n-(' + b + '))%' + a + '==0' :
                  'n<=' + b + '&&(n-(' + b + '))%' + a + '==0' : a=== 0 ?
                  'n==' + b :
                  (match[2] == 'last') ?
                    a == -1 ? 'n>=' + b : 'n<=' + b :
                    a == -1 ? 'n<=' + b : 'n>=' + b;

                // 4 cases: 1 (nth) x 4 (child, of-type, last-child, last-of-type)
                source =
                  'if(e!==h){' +
                    'n=s[' + (match[4] ? '"nthOfType"' : '"nthElement"') + ']' +
                      '(e,' + (match[2] == 'last' ? 'true' : 'false') + ');' +
                    'if(' + test + '){' + source + '}' +
                  '}';

              } else {
                // 6 cases: 3 (first, last, only) x 1 (child) x 2 (-of-type)
                a = match[2] == 'first' ? 'previous' : 'next';
                n = match[2] == 'only' ? 'previous' : 'next';
                b = match[2] == 'first' || match[2] == 'last';

                type = match[4] ? '&&n.nodeName!=e.nodeName' : '&&n.nodeName<"@"';

                source = 'if(e!==h){' +
                  ( 'n=e;while((n=n.' + a + 'Sibling)' + type + ');if(!n){' + (b ? source :
                    'n=e;while((n=n.' + n + 'Sibling)' + type + ');if(!n){' + source + '}') + '}' ) + '}';
              }
              break;
          }
        }

        // *** negation, user action and target pseudo-classes
        // *** UI element states and dynamic pseudo-classes
        // CSS3 :not, :checked, :enabled, :disabled, :target
        // CSS3 :active, :hover, :focus
        // CSS3 :link, :visited
        else if ((match = selector.match(Patterns.dpseudos)) &&
          CSS3PseudoClasses.Others[selector.match(reClassValue)[0]]) {

          switch (match[1]) {
            // CSS3 negation pseudo-class
            case 'not':
              // compile nested selectors, DO NOT pass the callback parameter
              // SIMPLENOT allow disabling complex selectors nested
              // in ':not()' pseudo-classes, breaks some test units
              expr = match[3].replace(reTrimSpaces, '');

              if (SIMPLENOT && !reSimpleNot.test(expr)) {
                // see above, log error but continue execution
                emit('Negation pseudo-class only accepts simple selectors "' + selector + '"');
                return '';
              } else {
                if ('compatMode' in doc) {
                  source = 'if(!' + compileGroup(expr, '', false) + '(e,s,r,d,h,g)){' + source + '}';
                } else {
                  source = 'if(!s.match(e, "' + expr.replace(/\x22/g, '\\"') + '",r)){' + source +'}';
                }
              }
              break;

            // CSS3 UI element states
            case 'checked':
              // only available for radio buttons and checkboxes
              source = 'if(typeof e.form!=="undefined"&&(/radio|checkbox/i).test(e.type)&&e.checked){' + source + '}';
              break;
            case 'disabled':
              // does not consider hidden input fields
              source = 'if(((typeof e.form!=="undefined"&&!(/hidden/i).test(e.type))||s.isLink(e))&&e.disabled){' + source + '}';
              break;
            case 'enabled':
              // does not consider hidden input fields
              source = 'if(((typeof e.form!=="undefined"&&!(/hidden/i).test(e.type))||s.isLink(e))&&!e.disabled){' + source + '}';
              break;

            // CSS3 lang pseudo-class
            case 'lang':
              test = '';
              if (match[3]) test = match[3].substr(0, 2) + '-';
              source = 'do{(n=e.lang||"").toLowerCase();' +
                'if((n==""&&h.lang=="' + match[3].toLowerCase() + '")||' +
                '(n&&(n=="' + match[3].toLowerCase() +
                '"||n.substr(0,3)=="' + test.toLowerCase() + '")))' +
                '{' + source + 'break;}}while((e=e.parentNode)&&e!==g);';
              break;

            // CSS3 target pseudo-class
            case 'target':
              n = doc.location ? doc.location.hash : '';
              if (n) {
                source = 'if(e.id=="' + n.slice(1) + '"){' + source + '}';
              }
              break;

            // CSS3 dynamic pseudo-classes
            case 'link':
              source = 'if(s.isLink(e)&&!e.visited){' + source + '}';
              break;
            case 'visited':
              source = 'if(s.isLink(e)&&e.visited){' + source + '}';
              break;

            // CSS3 user action pseudo-classes IE & FF3 have native support
            // these capabilities may be emulated by some event managers
            case 'active':
              if (isXMLDocument) break;
              source = 'if(e===d.activeElement){' + source + '}';
              break;
            case 'hover':
              if (isXMLDocument) break;
              source = 'if(e===d.hoverElement){' + source + '}';
              break;
            case 'focus':
              if (isXMLDocument) break;
              source = NATIVE_FOCUS ?
                'if(e===d.activeElement&&d.hasFocus()&&(e.type||e.href)){' + source + '}' :
                'if(e===d.activeElement&&(e.type||e.href)){' + source + '}';
              break;

            // CSS2 selected pseudo-classes, not part of current CSS3 drafts
            // the 'selected' property is only available for option elements
            case 'selected':
              // fix Safari selectedIndex property bug
              expr = BUGGY_SELECTED ? '||(n=e.parentNode)&&n.options[n.selectedIndex]===e' : '';
              source = 'if(e.nodeName=="OPTION"&&(e.selected' + expr + ')){' + source + '}';
              break;

            default:
              break;
          }
        } else {

          // this is where external extensions are
          // invoked if expressions match selectors
          expr = false;
          status = true;

          for (expr in Selectors) {
            if ((match = selector.match(Selectors[expr].Expression))) {
              result = Selectors[expr].Callback(match, source);
              source = result.source;
              status = result.status;
              if (status) break;
            }
          }

          // if an extension fails to parse the selector
          // it must return a false boolean in "status"
          if (!status) {
            // log error but continue execution, don't throw real exceptions
            // because blocking following processes maybe is not a good idea
            emit('Unknown pseudo-class selector "' + selector + '"');
            return '';
          }

          if (!expr) {
            // see above, log error but continue execution
            emit('Unknown token in selector "' + selector + '"');
            return '';
          }

        }

        // error if no matches found by the pattern scan
        if (!match) {
          emit('Invalid syntax in selector "' + selector + '"');
          return '';
        }

        // ensure "match" is not null or empty since
        // we do not throw real DOMExceptions above
        selector = match && match[match.length - 1];
      }

      return source;
    },

  /*----------------------------- QUERY METHODS ------------------------------*/

  // match element with selector
  // @return boolean
  match = function(element, selector, from, callback) {

      var changed, parts, resolver;

      // ensures a valid element node was passed
      if (!(element && element.nodeName > '@')) {
        emit("Invalid element argument");
        return false;
      }

      // ensures a valid selector string was passed
      if (!selector || typeof selector != 'string') {
        emit("Invalid selector argument");
        return false;
      }

      // if passed, check context contains element
      if (from && from.nodeType == 1) {
        if (!contains(from, element)) return false;
      } else if (from) {
        emit("Invalid context argument");
        return false;
      }

      selector = selector.replace(reTrimSpaces, '');

      // ensure context is set
      from || (from = doc);

      // extract context if changed
      if (lastMatchContext != from) {
        // save passed context
        lastMatchContext = from;
        // reference element ownerDocument and document root (HTML)
        root = (doc = element.ownerDocument || element).documentElement;
        isQuirksMode = isQuirks(doc);
        isXMLDocument = isXML(doc);
      }

      if ((changed = lastMatcher != selector)) {
        // process valid selector strings
        if ((parts = selector.match(reValidator)) && parts[0] == selector) {
          // save passed selector
          lastMatcher = selector;
          isSingleMatch = (parts = selector.match(reSplitGroup)).length < 2;
        } else {
          emit('The string "' + selector + '", is not a valid CSS selector');
          return false;
        }
      }

      // use matchesSelector API if available
      if (USE_QSAPI && element[NATIVE_MATCHES_SELECTOR] &&
        !(BUGGY_PSEUDOS && RE_PSEUDOS.test(selector)) &&
        !RE_BUGGY_QSAPI.test(selector)) {
        try {
          if (element[NATIVE_MATCHES_SELECTOR](selector)) {
            if (typeof callback == 'function') {
              callback(element);
            }
            return true;
          }
          return false;
        } catch(e) { }
      }

      // compile matcher resolver if necessary
      resolver = (isXMLDocument && XMLMatchers[selector]) ?
        XMLMatchers[selector] : HTMLMatchers[selector] ?
          HTMLMatchers[selector] : (isXMLDocument ?
            XMLMatchers : HTMLMatchers)[selector] = isSingleMatch ?
              new Function('e,s,r,d,h,g,f', 'var N,n,x=0,k=e;' +
                compileSelector(selector, 'f&&f(k);return true;') + 'return false;') :
              compileGroup(parts || selector, '', false);

      return resolver(element, snap, [ ], doc, root, from || doc, callback);
    },

  // select elements matching selector
  // using new Query Selector API
  // or cross-browser client API
  // @return array
  select = function(selector, from, callback) {

      var z, changed, element, elements, parts, resolver, token;

      if (arguments.length === 0) {
        emit('Missing required selector parameters');
        return [ ];
      } else if (selector === '') {
        emit('Empty selector string');
        return [ ];
      } else if (typeof selector != 'string') {
        // QSA capable browsers do not throw
        return [ ];
      }

      // ensure context is set
      from || (from = doc);

      if (RE_SIMPLE_SELECTOR.test(selector)) {
        switch (selector.charAt(0)) {
          case '#':
            if ((element = byId(selector.slice(1), from))) {
              callback && callback(element);
              return [ element ];
            }
            return [ ];
          case '.':
            elements = byClass(selector.slice(1), from);
            break;
          default:
            elements = byTag(selector, from);
            break;
        }
        return callback ?
          concatCall([ ], elements, callback) : elements;
      }

      if (USE_QSAPI && !RE_BUGGY_QSAPI.test(selector) &&
        QSA_NODE_TYPES[from.nodeType]) {

        // clear error state
        lastError = null;

        try {
          elements = from.querySelectorAll(selector);
        } catch(e) {
          // remember last error
          lastError = e;
          if (selector === '') throw e;
        }

        if (elements) {
          switch (elements.length) {
            case 0:
              return [ ];
            case 1:
              element = elements.item(0);
              callback && callback(element);
              return [ element ];
            default:
              return callback ?
                concatCall([ ], elements, callback) :
                NATIVE_SLICE_PROTO ?
                  slice.call(elements) :
                  concatList([ ], elements);
          }
        }
      }

      selector = selector.replace(reTrimSpaces, '');

      if (SHORTCUTS) {
        // add left context if missing
        if (reLeftContext.test(selector)) {
          selector = from.nodeType == 9 ? '* ' + selector :
            from.id ? '#' + from.id + ' ' + selector :
              selector;
        }
        // add right context if missing
        if (reRightContext.test(selector)) {
          selector = selector + ' *';
        }
      }

      // extract context if changed
      if (lastSelectContext != from) {
        // save passed context
        lastSelectContext = from;
        // reference context ownerDocument and document root (HTML)
        root = (doc = from.ownerDocument || from).documentElement;
        isQuirksMode = isQuirks(doc);
        isXMLDocument = isXML(doc);
      }

      if ((changed = lastSelector != selector)) {
        // process valid selector strings
        if ((parts = selector.match(reValidator)) && parts[0] == selector) {
          // save passed selector
          lastSelector = selector;
          isSingleSelect = (parts = selector.match(reSplitGroup)).length < 2;
        } else {
          emit('The string "' + selector + '", is not a valid CSS selector');
          return [ ];
        }
      }

      // commas separators are treated sequentially to maintain order
      if (isSingleSelect && from.nodeType != 11) {

        if (changed) {
          // get right most selector token
          parts = selector.match(reSplitToken);
          token = parts[parts.length - 1];

          // position where token was found
          lastPosition = selector.length - token.length;

          // only last slice before :not rules
          lastSlice = token.split(':not')[0];
        }

        // ID optimization RTL, to reduce number of elements to visit
        if ((parts = lastSlice.match(Optimize.ID)) && (token = parts[1])) {
          if ((element = byId(token, from))) {
            if (match(element, selector)) {
              callback && callback(element);
              return [ element ];
            }
          }
          return [ ];
        }

        // ID optimization LTR, to reduce selection context searches
        else if ((parts = selector.match(Optimize.ID)) && (token = parts[1])) {
          if ((element = byId(token, doc))) {
            if ('#' + token == selector) {
              callback && callback(element);
              return [ element ];
            }
            if (/[>+~]/.test(selector)) {
              from = element.parentNode;
            } else {
              selector = selector.replace('#' + token, '*');
              lastPosition -= token.length + 1;
              from = element;
            }
          } else return [ ];
        }

        if (!NATIVE_GEBCN && (parts = lastSlice.match(Optimize.TAG)) && (token = parts[1])) {
          if ((elements = byTag(token, from)).length === 0) { return [ ]; }
          selector = selector.slice(0, lastPosition) + selector.slice(lastPosition).replace(token, '*');
        }

        else if ((parts = lastSlice.match(Optimize.CLASS)) && (token = parts[1])) {
          if ((elements = byClass(token, from)).length === 0) { return [ ]; }
          if (reOptimizeSelector.test(selector.charAt(selector.indexOf(token) - 1))) {
            selector = selector.slice(0, lastPosition) + selector.slice(lastPosition).replace('.' + token, '');
          } else {
            selector = selector.slice(0, lastPosition) + selector.slice(lastPosition).replace('.' + token, '*');
          }
        }

        else if ((parts = selector.match(Optimize.CLASS)) && (token = parts[1])) {
          if ((elements = byClass(token, from)).length === 0) { return [ ]; }
          for (z = 0, els = [ ]; elements.length > z; ++z) {
            els = concatList(els, elements[z].getElementsByTagName('*'));
          }
          elements = els;
          if (reOptimizeSelector.test(selector.charAt(selector.indexOf(token) - 1))) {
            selector = selector.slice(0, lastPosition) + selector.slice(lastPosition).replace('.' + token, '');
          } else {
            selector = selector.slice(0, lastPosition) + selector.slice(lastPosition).replace('.' + token, '*');
          }
        }

        else if (NATIVE_GEBCN && (parts = lastSlice.match(Optimize.TAG)) && (token = parts[1])) {
          if ((elements = byTag(token, from)).length === 0) { return [ ]; }
          selector = selector.slice(0, lastPosition) + selector.slice(lastPosition).replace(token, '*');
        }

      }

      if (!elements) {
        elements = byTag('*', from);
      }
      // end of prefiltering pass

      // compile selector resolver if necessary
      resolver = (isXMLDocument && XMLResolvers[selector]) ?
        XMLResolvers[selector] : HTMLResolvers[selector] ?
          HTMLResolvers[selector] : (isXMLDocument ?
            XMLResolvers : HTMLResolvers)[selector] = isSingleSelect ?
              new Function('c,s,r,d,h,g,f', 'var N,n,x=0,k=-1,e;main:while((e=c[++k])){' +
                compileSelector(selector, ACCEPT_NODE) + '}return r;') :
              compileGroup(parts || selector, '', true);

      return resolver(elements, snap, [ ], doc, root, from, callback);
    },

  /*-------------------------------- STORAGE ---------------------------------*/

  // compiled select functions returning collections
  HTMLResolvers = { },
  XMLResolvers = { },

  // compiled match functions returning booleans
  HTMLMatchers = { },
  XMLMatchers = { },

  // used to pass methods to compiled functions
  snap = {

    // element indexing methods
    nthElement: nthElement,
    nthOfType: nthOfType,

    // element inspection methods
    getAttribute: getAttribute,
    hasAttribute: hasAttribute,

    // element selection methods
    byClass: byClass,
    byName: byName,
    byTag: byTag,
    byId: byId,

    // helper/check methods
    contains: contains,
    isEmpty: isEmpty,
    isLink: isLink,

    // selection/matching
    select: select,
    match: match
  };

  /*------------------------------- PUBLIC API -------------------------------*/

  return {

    // retrieve element by id attr
    byId: byId,

    // retrieve elements by tag name
    byTag: byTag,

    // retrieve elements by name attr
    byName: byName,

    // retrieve elements by class name
    byClass: byClass,

    // read the value of the attribute
    // as was in the original HTML code
    getAttribute: getAttribute,

    // check for the attribute presence
    // as was in the original HTML code
    hasAttribute: hasAttribute,

    // element match selector, return boolean true/false
    match: match,

    // elements matching selector, starting from element
    select: select,

    // compile selector into ad-hoc javascript resolver
    compile: compile,

    // check that two elements are ancestor/descendant
    contains: contains,

    // handle selector engine configuration settings
    configure: configure,

    // add or overwrite user defined operators
    registerOperator: function(symbol, resolver) {
        if (!Operators[symbol]) {
          Operators[symbol] = resolver;
        }
      },

    // add selector patterns for user defined callbacks
    registerSelector: function(name, rexp, func) {
        if (!Selectors[name]) {
          Selectors[name] = { };
          Selectors[name].Expression = rexp;
          Selectors[name].Callback = func;
        }
      }
  };

};
// Generated by CoffeeScript 1.3.3

/*
Copyright (c) 2011 Jesse Dailey <jesse.dailey@gmail.com>
License: MIT License - http://www.opensource.org/licenses/mit-license.php
*/


(function() {
  var Attr, CComment, CData, Comment, Document, DocumentFragment, ELEMENT_MAP, Element, Entity, Event, HTMLAnchorElement, HTMLAreaElement, HTMLAudioElement, HTMLBRElement, HTMLBaseElement, HTMLBlockquoteElement, HTMLBodyElement, HTMLButtonElement, HTMLCanvasElement, HTMLDListElement, HTMLDelElement, HTMLDetailsElement, HTMLDivElement, HTMLDocument, HTMLElement, HTMLEmbedElement, HTMLFieldSetElement, HTMLFormElement, HTMLHRElement, HTMLHeadElement, HTMLHeading2Element, HTMLHeading3Element, HTMLHeading4Element, HTMLHeading5Element, HTMLHeading6Element, HTMLHeadingElement, HTMLHtmlElement, HTMLIFrameElement, HTMLImageElement, HTMLInputElement, HTMLInsElement, HTMLKeygenElement, HTMLLIElement, HTMLLabelElement, HTMLLegendElement, HTMLLinkElement, HTMLMapElement, HTMLMenuElement, HTMLMetaElement, HTMLMeterElement, HTMLOListElement, HTMLObjectElement, HTMLOptGroupElement, HTMLOptionElement, HTMLOutputElement, HTMLParagraphElement, HTMLParamElement, HTMLPreElement, HTMLProgressElement, HTMLQuoteElement, HTMLScriptElement, HTMLSelectElement, HTMLSourceElement, HTMLStyleElement, HTMLTableBodyElement, HTMLTableCaptionElement, HTMLTableCellElement, HTMLTableColElement, HTMLTableElement, HTMLTableFootElement, HTMLTableHeadElement, HTMLTableRowElement, HTMLTextAreaElement, HTMLTitleElement, HTMLUListElement, HTMLVideoElement, MutationEvent, Node, NotSupported, Text, extend, getInnerText, htmlescape, htmlparse, htmlunescape, matcher, parser, property, repeat, setInnerText,
    __hasProp = {}.hasOwnProperty,
    __extends = function(child, parent) { for (var key in parent) { if (__hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
    __indexOf = [].indexOf || function(item) { for (var i = 0, l = this.length; i < l; i++) { if (i in this && this[i] === item) return i; } return -1; },
    __slice = [].slice;

  parser = privates;

  htmlparse = parser.parse;

  htmlescape = parser.escape;

  htmlunescape = parser.unescape;

  matcher = privates;

  NotSupported = function() {
    throw Error("NOT_SUPPORTED");
  };

  repeat = function(s, n) {
    n = Math.max(0, n);
    switch (n) {
      case 0:
        return "";
      case 1:
        return s;
      default:
        return s + repeat(s, n - 1);
    }
  };

  extend = function(o, p) {
    var k;
    o || (o = {});
    for (k in p) {
      o[k] = p[k];
    }
    return o;
  };

  property = function(o, k, props) {
    return Object.defineProperty(o, k, extend({
      enumerable: true,
      configurable: true
    }, props));
  };

  Event = (function() {

    Event.CAPTURING_PHASE = 1;

    Event.AT_TARGET = 2;

    Event.BUBBLING_PHASE = 3;

    function Event() {
      this.type = null;
      this.target = null;
      this.currentTarget = null;
      this.eventPhase = 0;
      this.bubbles = false;
      this.cancelable = true;
      this.timeStamp = 0;
    }

    Event.prototype.stopPropagation = function() {};

    Event.prototype.preventDefault = function() {};

    Event.prototype.initEvent = function(type, canBubble, cancelable) {
      this.type = type;
      this.bubbles = canBubble;
      this.cancelable = cancelable;
      return this.timeStamp = new Date().getTime();
    };

    return Event;

  })();

  MutationEvent = (function(_super) {

    __extends(MutationEvent, _super);

    MutationEvent.MODIFICATION = 1;

    MutationEvent.ADDITION = 2;

    MutationEvent.REMOVAL = 3;

    function MutationEvent() {
      this.relatedNode = null;
      this.prevValue = null;
      this.newValue = null;
      this.attrName = null;
      this.attrChange = 0;
    }

    MutationEvent.prototype.initMutationEvent = function(type, canBubble, cancelable, relatedNode, prevValue, newValue, attrName, attrChange) {
      this.type = type;
      this.bubbles = canBubble;
      this.cancelable = cancelable;
      this.relatedNode = relatedNode;
      this.prevValue = prevValue;
      this.newValue = newValue;
      this.attrName = attrName;
      return this.attrChange = attrChange;
    };

    return MutationEvent;

  })(Event);

  Node = (function() {
    var addEventListener;

    Node.ELEMENT_NODE = 1;

    Node.ATTRIBUTE_NODE = 2;

    Node.TEXT_NODE = 3;

    Node.CDATA_SECTION_NODE = 4;

    Node.ENTITY_REFERENCE_NODE = 5;

    Node.ENTITY_NODE = 6;

    Node.PROCESSING_INSTRUCTION_NODE = 7;

    Node.COMMENT_NODE = 8;

    Node.DOCUMENT_NODE = 9;

    Node.DOCUMENT_TYPE_NODE = 10;

    Node.DOCUMENT_FRAGMENT_NODE = 11;

    Node.NOTATION_NODE = 12;

    Node.DOCUMENT_POSITION_DISCONNECTED = 1;

    Node.DOCUMENT_POSITION_PRECEDING = 2;

    Node.DOCUMENT_POSITION_FOLLOWING = 4;

    Node.DOCUMENT_POSITION_CONTAINS = 8;

    Node.DOCUMENT_POSITION_CONTAINED_BY = 16;

    Node.DOCUMENT_POSITION_IMPLEMENTATION_SPECIFIC = 32;

    function Node(name, value, type, ownerDocument) {
      if (value == null) {
        value = null;
      }
      if (type == null) {
        type = 1;
      }
      if (ownerDocument == null) {
        ownerDocument = null;
      }
      this._private = {
        nodeName: null,
        parentNode: null,
        childIndex: -1,
        classes: []
      };
      this.nodeName = name;
      this.nodeValue = value;
      this.nodeType = type;
      this.ownerDocument = ownerDocument;
      this.childNodes = [];
      this.attributes = {};
      this.listeners = {
        "true": {},
        "false": {}
      };
    }

    Node.prototype.addEventListener = addEventListener = function(type, listener, useCapture) {
      var list, _base, _ref;
      if (useCapture == null) {
        useCapture = false;
      }
      list = ((_ref = (_base = this.listeners[useCapture])[type]) != null ? _ref : _base[type] = []);
      if (__indexOf.call(list, listener) < 0) {
        return list.push(listener);
      }
    };

    Node.prototype.attachEventListener = addEventListener;

    Node.prototype.removeEventListener = function(type, listener, useCapture) {
      var i, list, _base, _ref;
      if (listener == null) {
        listener = null;
      }
      if (useCapture == null) {
        useCapture = false;
      }
      list = ((_ref = (_base = this.listeners[useCapture])[type]) != null ? _ref : _base[type] = []);
      i = list.indexOf(listener);
      return list.splice(i, 1);
    };

    Node.prototype.dispatchEvent = function(evt) {
      var ancestor, chain, handler, list, prevented, stopped, _i, _j, _k, _l, _len, _len1, _len2, _len3, _len4, _m, _ref, _results;
      prevented = false;
      stopped = false;
      evt.preventDefault = function() {
        if (evt.cancelable) {
          return prevented = true;
        }
      };
      evt.stopPropagation = function() {
        return stopped = true;
      };
      evt.target = this;
      evt.eventPhase = Event.CAPTURING_PHASE;
      chain = [this];
      while (chain[0].parentNode !== this.ownerDocument) {
        chain.unshift(chain[0].parentNode);
      }
      chain.unshift(this.ownerDocument);
      for (_i = 0, _len = chain.length; _i < _len; _i++) {
        ancestor = chain[_i];
        evt.currentTarget = ancestor;
        list = ancestor.listeners[true][evt.type];
        if (list) {
          for (_j = 0, _len1 = list.length; _j < _len1; _j++) {
            handler = list[_j];
            handler(evt);
          }
        }
        if (stopped) {
          break;
        }
      }
      evt.eventPhase = Event.AT_TARGET;
      evt.currentTarget = evt.target;
      list = this.listeners[true][evt.type];
      if (list) {
        for (_k = 0, _len2 = list.length; _k < _len2; _k++) {
          handler = list[_k];
          handler(evt);
        }
      }
      list = this.listeners[false][evt.type];
      if (list) {
        for (_l = 0, _len3 = list.length; _l < _len3; _l++) {
          handler = list[_l];
          handler(evt);
        }
      }
      if (evt.bubbles) {
        _ref = chain.reverse();
        _results = [];
        for (_m = 0, _len4 = _ref.length; _m < _len4; _m++) {
          ancestor = _ref[_m];
          evt.currentTarget = ancestor;
          list = ancestor.listeners[false][evt.type];
          if (list) {
            _results.push((function() {
              var _len5, _n, _results1;
              _results1 = [];
              for (_n = 0, _len5 = list.length; _n < _len5; _n++) {
                handler = list[_n];
                _results1.push(handler(evt));
              }
              return _results1;
            })());
          } else {
            _results.push(void 0);
          }
        }
        return _results;
      }
    };

    Node.prototype.cloneNode = function(deep) {
      var a, c, ret, _i, _len, _ref;
      if (deep == null) {
        deep = false;
      }
      ret = (function() {
        switch (this.constructor) {
          case Text:
          case Comment:
          case CData:
            return new this.constructor(this.nodeValue, this.ownerDocument);
          case Attr:
            return new this.constructor(this.nodeName, this.nodeValue);
          default:
            return new this.constructor(this.nodeName, this.nodeValue, this.nodeType, this.ownerDocument);
        }
      }).call(this);
      for (a in this._private) {
        ret._private[a] = this._private[a];
      }
      for (a in this.attributes) {
        ret.attributes[a] = this.attributes[a];
      }
      if (deep) {
        _ref = this.childNodes;
        for (_i = 0, _len = _ref.length; _i < _len; _i++) {
          c = _ref[_i];
          ret.childNodes.push(c.cloneNode(true));
        }
      }
      return ret;
    };

    Node.prototype.hasAttributes = function() {
      var a;
      for (a in this.attributes) {
        return true;
      }
      return false;
    };

    Node.prototype.isSameNode = function(node) {
      return node === this;
    };

    Node.prototype.hasChildNodes = function() {
      return this.childNodes.length > 0;
    };

    Node.prototype.insertBefore = function(newNode, refNode) {
      var c, i, _i, _j, _len, _len1, _ref, _ref1;
      if (!(refNode != null)) {
        return this.appendChild(newNode);
      }
      if (refNode.parentNode !== this) {
        throw Error("Cannot insertBefore a non-child.");
      }
      if (newNode.nodeType === Node.DOCUMENT_FRAGMENT_NODE) {
        _ref = newNode.childNodes;
        for (_i = 0, _len = _ref.length; _i < _len; _i++) {
          c = _ref[_i];
          this.insertBefore(c, refNode);
        }
      } else {
        i = refNode._private.childIndex;
        if (i > -1) {
          this.childNodes.splice(i, 0, newNode);
          newNode._private.childIndex = i;
          newNode._private.parentNode = this;
          refNode._private.childIndex = i + 1;
          i = 0;
          _ref1 = this.childNodes;
          for (_j = 0, _len1 = _ref1.length; _j < _len1; _j++) {
            c = _ref1[_j];
            c._private.childIndex = i++;
          }
        }
      }
      return newNode;
    };

    Node.prototype.appendChild = function(node) {
      var c, _i, _len, _ref, _results;
      if (!(node != null)) {
        return;
      }
      if (node.nodeType === Node.DOCUMENT_FRAGMENT_NODE) {
        _ref = node.childNodes;
        _results = [];
        for (_i = 0, _len = _ref.length; _i < _len; _i++) {
          c = _ref[_i];
          _results.push(this.appendChild(c));
        }
        return _results;
      } else {
        node._private.parentNode = this;
        node._private.childIndex = this.childNodes.length;
        return this.childNodes.push(node);
      }
    };

    Node.prototype.removeChild = function(node) {
      var c, i, _i, _len, _ref;
      if (typeof node === "number") {
        node = this.childNodes[node];
      }
      i = node._private.childIndex;
      if (i > -1 && node.parentNode === this) {
        node._private.parentNode = null;
        node._private.childIndex = -1;
        this.childNodes.splice(i, 1);
        i = 0;
        _ref = this.childNodes;
        for (_i = 0, _len = _ref.length; _i < _len; _i++) {
          c = _ref[_i];
          c._private.childIndex = i++;
        }
      } else {
        throw Error("Cannot removeChild a non-child.");
      }
      return node;
    };

    Node.prototype.replaceChild = function(newNode, oldNode) {
      var c, i, _i, _len, _ref;
      if (oldNode.parentNode !== this) {
        throw Error("Cannot replaceChild a non-child.");
      }
      i = oldNode._private.childIndex;
      if (i < 0) {
        throw Error("DOM tree corruption, childIndex is < 0");
      }
      if (newNode.nodeType === Node.DOCUMENT_FRAGMENT_NODE) {
        _ref = this.childNodes;
        for (_i = 0, _len = _ref.length; _i < _len; _i++) {
          c = _ref[_i];
          this.insertBefore(c, oldNode);
        }
        return this.removeChild(oldNode);
      }
      newNode._private.parentNode = this;
      newNode._private.childIndex = i;
      oldNode._private.parentNode = null;
      oldNode._private.childIndex = -1;
      this.childNodes.splice(i, 1, newNode);
      return oldNode;
    };

    Node.prototype.toString = function(pretty, deep, indentLevel) {
      var body, c, indent, newline;
      if (pretty == null) {
        pretty = false;
      }
      if (deep == null) {
        deep = true;
      }
      if (indentLevel == null) {
        indentLevel = 0;
      }
      if (pretty) {
        indent = repeat("  ", indentLevel);
        newline = "\n";
      } else {
        indent = "";
        newline = "";
      }
      switch (this.nodeType) {
        case Node.TEXT_NODE:
          return ("" + indent + this.nodeValue) + newline;
        case Node.ELEMENT_NODE:
          return Element.prototype.toString.call(this, pretty, deep, indentLevel);
        case Node.ATTRIBUTE_NODE:
          if (this.nodeValue !== "") {
            return "" + indent + this.nodeName + "=\"" + this.nodeValue + "\"";
          }
          break;
        case Node.CDATA_SECTION_NODE:
          return ("" + indent + "<![CDATA[" + this.nodeValue + "]]>") + newline;
        case Node.COMMENT_NODE:
          body = "";
          if (this.nodeName === "#CCOMMENT") {
            body = '>' + newline + ((function() {
              var _i, _len, _ref, _results;
              _ref = this.childNodes;
              _results = [];
              for (_i = 0, _len = _ref.length; _i < _len; _i++) {
                c = _ref[_i];
                _results.push(c.toString(pretty, deep, indentLevel + 1));
              }
              return _results;
            }).call(this)).join('');
            body += indent + "<![endif]";
          }
          return ("" + indent + "<!--" + this.nodeValue + body + "-->") + newline;
        case Node.DOCUMENT_TYPE_NODE:
          return ("" + indent + "<!DOCTYPE " + this.nodeValue + ">") + newline;
        case Node.DOCUMENT_NODE:
          return Element.prototype.toString.call(this, pretty, deep, indentLevel);
        case Node.DOCUMENT_FRAGMENT_NODE:
          return NotSupported();
      }
    };

    return Node;

  })();

  property(Node.prototype, 'nodeName', {
    get: function() {
      return this._private.nodeName;
    },
    set: function(v) {
      return this._private.nodeName = v != null ? v.toUpperCase() : void 0;
    }
  });

  property(Node.prototype, 'previousSibling', {
    get: function() {
      var _ref;
      return (_ref = this.parentNode) != null ? _ref.childNodes[this._private.childIndex - 1] : void 0;
    }
  });

  property(Node.prototype, 'nextSibling', {
    get: function() {
      var _ref;
      return (_ref = this.parentNode) != null ? _ref.childNodes[this._private.childIndex + 1] : void 0;
    }
  });

  property(Node.prototype, 'parentNode', {
    get: function() {
      return this._private.parentNode;
    },
    set: function(v) {
      var _ref;
      if (v !== null) {
        throw Error("Must use one of appendChild, insertBefore, etc. to give a Node a new parent.");
      }
      if ((_ref = this._private.parentNode) != null) {
        _ref.removeChild(this);
      }
      this._private.parentNode = null;
      return this._private.childIndex = -1;
    }
  });

  property(Node.prototype, 'firstChild', {
    get: function() {
      return this.childNodes[0];
    }
  });

  property(Node.prototype, 'lastChild', {
    get: function() {
      return this.childNodes[this.childNodes.length - 1];
    }
  });

  Entity = (function(_super) {

    __extends(Entity, _super);

    function Entity() {
      var a, _ref;
      a = 1 <= arguments.length ? __slice.call(arguments, 0) : [];
      if ((_ref = a[2]) == null) {
        a[2] = Node.ENTITY_NODE;
      }
      Entity.__super__.constructor.apply(this, a);
    }

    return Entity;

  })(Node);

  Element = (function(_super) {

    __extends(Element, _super);

    function Element() {
      var a, _ref;
      a = 1 <= arguments.length ? __slice.call(arguments, 0) : [];
      if ((_ref = a[2]) == null) {
        a[2] = Node.ELEMENT_NODE;
      }
      Element.__super__.constructor.apply(this, a);
      this.style = {};
    }

    Element.prototype.getElementsByClassName = function(name) {
      var c, i, ret, _i, _j, _len, _len1, _ref, _ref1;
      ret = [];
      _ref = this.childNodes;
      for (_i = 0, _len = _ref.length; _i < _len; _i++) {
        c = _ref[_i];
        if (c.nodeType === Node.ELEMENT_NODE) {
          if (name === "*" || __indexOf.call(c._private.classes, name) >= 0) {
            ret.push(c);
          }
          _ref1 = c.getElementsByClassName(name);
          for (_j = 0, _len1 = _ref1.length; _j < _len1; _j++) {
            i = _ref1[_j];
            ret.push(i);
          }
        }
      }
      return ret;
    };

    Element.prototype.getElementsByTagName = function(name) {
      var c, i, ret, uname, _i, _j, _len, _len1, _ref, _ref1;
      ret = [];
      uname = name.toUpperCase();
      _ref = this.childNodes;
      for (_i = 0, _len = _ref.length; _i < _len; _i++) {
        c = _ref[_i];
        if (c.nodeType === Node.ELEMENT_NODE) {
          if (uname === "*" || uname === c.tagName) {
            ret.push(c);
          }
          _ref1 = c.getElementsByTagName(uname);
          for (_j = 0, _len1 = _ref1.length; _j < _len1; _j++) {
            i = _ref1[_j];
            ret.push(i);
          }
        }
      }
      return ret;
    };

    Element.prototype.getAttribute = function(name) {
      return this.attributes[name] || "";
    };

    Element.prototype.getAttributeNode = function(name) {
      var n;
      n = new Attr(name, this.getAttribute(name));
      n.ownerElement = this;
      n.ownerDocument = this.ownerDocument;
      return n;
    };

    Element.prototype.hasAttribute = function(name) {
      return name in this.attributes;
    };

    Element.prototype.setAttribute = function(name, value) {
      if (!(value != null)) {
        this.removeAttribute(name);
      }
      switch (name) {
        case "class":
          return this.className = value;
        case "id":
          return this.id = value;
        default:
          return this.attributes[name] = value;
      }
    };

    Element.prototype.removeAttribute = function(name) {
      var _ref;
      delete this.attributes[name];
      switch (name) {
        case "class":
          return this._private.classes = [];
        case "id":
          return (_ref = this.ownerDocument) != null ? delete _ref._private.idMap[this.id] : void 0;
      }
    };

    Element.prototype.matchesSelector = function(selector) {
      var _ref;
      return (_ref = this.ownerDocument) != null ? _ref._private.matcher.match(this, selector) : void 0;
    };

    Element.prototype.querySelector = function(selector) {
      var _ref;
      return (_ref = this.ownerDocument) != null ? _ref._private.matcher.select(selector, this)[0] : void 0;
    };

    Element.prototype.querySelectorAll = function(selector) {
      var _ref;
      return (_ref = this.ownerDocument) != null ? _ref._private.matcher.select(selector, this) : void 0;
    };

    Element.prototype.scrollByLines = NotSupported;

    Element.prototype.scrollByPages = NotSupported;

    Element.prototype.scrollIntoView = NotSupported;

    Element.prototype.scrollIntoViewIfNeeded = NotSupported;

    Element.prototype.getBoundingClientRect = NotSupported;

    Element.prototype.getClientRects = NotSupported;

    Element.prototype.focus = NotSupported;

    Element.prototype.blur = NotSupported;

    Element.prototype.toString = function(pretty, deep, indentLevel) {
      var a, attrs, c, end, indent, len, name, newline, r, ret, _i, _len, _ref, _ref1;
      if (pretty == null) {
        pretty = false;
      }
      if (deep == null) {
        deep = true;
      }
      if (indentLevel == null) {
        indentLevel = 0;
      }
      name = (_ref = this.nodeName) != null ? _ref.toLowerCase() : void 0;
      if (pretty && deep) {
        indent = repeat("  ", indentLevel);
        newline = "\n";
      } else {
        indent = "";
        newline = "";
      }
      attrs = ((function() {
        var _results;
        _results = [];
        for (a in this.attributes) {
          _results.push(a.length > 0 && this.attributes[a] !== "" ? " " + a + "=\"" + this.attributes[a] + "\"" : void 0);
        }
        return _results;
      }).call(this)).join('');
      attrs += ((function() {
        var _results;
        _results = [];
        for (a in this.attributes) {
          _results.push(a.length > 0 && this.attributes[a] === "" ? " " + a : void 0);
        }
        return _results;
      }).call(this)).join('');
      len = this.childNodes.length;
      end = (function() {
        switch (len) {
          case 0:
            return "/";
          default:
            return "";
        }
      })();
      ret = [indent + ("<" + name + attrs + end + ">") + newline];
      r = 1;
      if (deep) {
        _ref1 = this.childNodes;
        for (_i = 0, _len = _ref1.length; _i < _len; _i++) {
          c = _ref1[_i];
          ret[r++] = c.toString(pretty, deep, indentLevel + 1);
        }
      } else if (len > 0) {
        ret[r++] = indent + ("..." + len + " children...") + newline;
      }
      if (len > 0) {
        ret[r++] = indent + ("</" + name + ">") + newline;
      }
      return ret.join('');
    };

    return Element;

  })(Node);

  ELEMENT_MAP = {
    _: HTMLElement = (function(_super) {

      __extends(HTMLElement, _super);

      function HTMLElement() {
        var a;
        a = 1 <= arguments.length ? __slice.call(arguments, 0) : [];
        HTMLElement.__super__.constructor.apply(this, a);
      }

      return HTMLElement;

    })(Element),
    a: HTMLAnchorElement = (function(_super) {

      __extends(HTMLAnchorElement, _super);

      function HTMLAnchorElement() {
        var a;
        a = 1 <= arguments.length ? __slice.call(arguments, 0) : [];
        a[0] = "A";
        HTMLAnchorElement.__super__.constructor.apply(this, a);
      }

      return HTMLAnchorElement;

    })(HTMLElement),
    area: HTMLAreaElement = (function(_super) {

      __extends(HTMLAreaElement, _super);

      function HTMLAreaElement() {
        var a;
        a = 1 <= arguments.length ? __slice.call(arguments, 0) : [];
        a[0] = "AREA";
        HTMLAreaElement.__super__.constructor.apply(this, a);
      }

      return HTMLAreaElement;

    })(HTMLElement),
    audio: HTMLAudioElement = (function(_super) {

      __extends(HTMLAudioElement, _super);

      function HTMLAudioElement() {
        var a;
        a = 1 <= arguments.length ? __slice.call(arguments, 0) : [];
        a[0] = "AUDIO";
        HTMLAudioElement.__super__.constructor.apply(this, a);
      }

      return HTMLAudioElement;

    })(HTMLElement),
    base: HTMLBaseElement = (function(_super) {

      __extends(HTMLBaseElement, _super);

      function HTMLBaseElement() {
        var a;
        a = 1 <= arguments.length ? __slice.call(arguments, 0) : [];
        a[0] = "BASE";
        HTMLBaseElement.__super__.constructor.apply(this, a);
      }

      return HTMLBaseElement;

    })(HTMLElement),
    blockquote: HTMLBlockquoteElement = (function(_super) {

      __extends(HTMLBlockquoteElement, _super);

      function HTMLBlockquoteElement() {
        var a;
        a = 1 <= arguments.length ? __slice.call(arguments, 0) : [];
        a[0] = "BLOCKQUOTE";
        HTMLBlockquoteElement.__super__.constructor.apply(this, a);
      }

      return HTMLBlockquoteElement;

    })(HTMLElement),
    body: HTMLBodyElement = (function(_super) {

      __extends(HTMLBodyElement, _super);

      function HTMLBodyElement() {
        var a;
        a = 1 <= arguments.length ? __slice.call(arguments, 0) : [];
        a[0] = "BODY";
        HTMLBodyElement.__super__.constructor.apply(this, a);
      }

      return HTMLBodyElement;

    })(HTMLElement),
    br: HTMLBRElement = (function(_super) {

      __extends(HTMLBRElement, _super);

      function HTMLBRElement() {
        var a;
        a = 1 <= arguments.length ? __slice.call(arguments, 0) : [];
        a[0] = "BR";
        HTMLBRElement.__super__.constructor.apply(this, a);
      }

      return HTMLBRElement;

    })(HTMLElement),
    button: HTMLButtonElement = (function(_super) {

      __extends(HTMLButtonElement, _super);

      function HTMLButtonElement() {
        var a;
        a = 1 <= arguments.length ? __slice.call(arguments, 0) : [];
        a[0] = "BUTTON";
        HTMLButtonElement.__super__.constructor.apply(this, a);
      }

      return HTMLButtonElement;

    })(HTMLElement),
    canvas: HTMLCanvasElement = (function(_super) {

      __extends(HTMLCanvasElement, _super);

      function HTMLCanvasElement() {
        var a;
        a = 1 <= arguments.length ? __slice.call(arguments, 0) : [];
        a[0] = "CANVAS";
        HTMLCanvasElement.__super__.constructor.apply(this, a);
      }

      return HTMLCanvasElement;

    })(HTMLElement),
    caption: HTMLTableCaptionElement = (function(_super) {

      __extends(HTMLTableCaptionElement, _super);

      function HTMLTableCaptionElement() {
        var a;
        a = 1 <= arguments.length ? __slice.call(arguments, 0) : [];
        a[0] = "CAPTION";
        HTMLTableCaptionElement.__super__.constructor.apply(this, a);
      }

      return HTMLTableCaptionElement;

    })(HTMLElement),
    col: HTMLTableColElement = (function(_super) {

      __extends(HTMLTableColElement, _super);

      function HTMLTableColElement() {
        var a;
        a = 1 <= arguments.length ? __slice.call(arguments, 0) : [];
        a[0] = "COL";
        HTMLTableColElement.__super__.constructor.apply(this, a);
      }

      return HTMLTableColElement;

    })(HTMLElement),
    colgroup: HTMLTableColElement = (function(_super) {

      __extends(HTMLTableColElement, _super);

      function HTMLTableColElement() {
        var a;
        a = 1 <= arguments.length ? __slice.call(arguments, 0) : [];
        a[0] = "COLGROUP";
        HTMLTableColElement.__super__.constructor.apply(this, a);
      }

      return HTMLTableColElement;

    })(HTMLElement),
    del: HTMLDelElement = (function(_super) {

      __extends(HTMLDelElement, _super);

      function HTMLDelElement() {
        var a;
        a = 1 <= arguments.length ? __slice.call(arguments, 0) : [];
        a[0] = "DEL";
        HTMLDelElement.__super__.constructor.apply(this, a);
      }

      return HTMLDelElement;

    })(HTMLElement),
    details: HTMLDetailsElement = (function(_super) {

      __extends(HTMLDetailsElement, _super);

      function HTMLDetailsElement() {
        var a;
        a = 1 <= arguments.length ? __slice.call(arguments, 0) : [];
        a[0] = "DETAILS";
        HTMLDetailsElement.__super__.constructor.apply(this, a);
      }

      return HTMLDetailsElement;

    })(HTMLElement),
    div: HTMLDivElement = (function(_super) {

      __extends(HTMLDivElement, _super);

      function HTMLDivElement() {
        var a;
        a = 1 <= arguments.length ? __slice.call(arguments, 0) : [];
        a[0] = "DIV";
        HTMLDivElement.__super__.constructor.apply(this, a);
      }

      return HTMLDivElement;

    })(HTMLElement),
    dl: HTMLDListElement = (function(_super) {

      __extends(HTMLDListElement, _super);

      function HTMLDListElement() {
        var a;
        a = 1 <= arguments.length ? __slice.call(arguments, 0) : [];
        a[0] = "DL";
        HTMLDListElement.__super__.constructor.apply(this, a);
      }

      return HTMLDListElement;

    })(HTMLElement),
    embed: HTMLEmbedElement = (function(_super) {

      __extends(HTMLEmbedElement, _super);

      function HTMLEmbedElement() {
        var a;
        a = 1 <= arguments.length ? __slice.call(arguments, 0) : [];
        a[0] = "EMBED";
        HTMLEmbedElement.__super__.constructor.apply(this, a);
      }

      return HTMLEmbedElement;

    })(HTMLElement),
    fieldSet: HTMLFieldSetElement = (function(_super) {

      __extends(HTMLFieldSetElement, _super);

      function HTMLFieldSetElement() {
        var a;
        a = 1 <= arguments.length ? __slice.call(arguments, 0) : [];
        a[0] = "FIELDSET";
        HTMLFieldSetElement.__super__.constructor.apply(this, a);
      }

      return HTMLFieldSetElement;

    })(HTMLElement),
    form: HTMLFormElement = (function(_super) {

      __extends(HTMLFormElement, _super);

      function HTMLFormElement() {
        var a;
        a = 1 <= arguments.length ? __slice.call(arguments, 0) : [];
        a[0] = "FORM";
        HTMLFormElement.__super__.constructor.apply(this, a);
      }

      return HTMLFormElement;

    })(HTMLElement),
    h1: HTMLHeadingElement = (function(_super) {

      __extends(HTMLHeadingElement, _super);

      function HTMLHeadingElement() {
        var a;
        a = 1 <= arguments.length ? __slice.call(arguments, 0) : [];
        a[0] = "H1";
        HTMLHeadingElement.__super__.constructor.apply(this, a);
      }

      return HTMLHeadingElement;

    })(HTMLElement),
    h2: HTMLHeading2Element = (function(_super) {

      __extends(HTMLHeading2Element, _super);

      function HTMLHeading2Element() {
        var a;
        a = 1 <= arguments.length ? __slice.call(arguments, 0) : [];
        a[0] = "H1";
        HTMLHeading2Element.__super__.constructor.apply(this, a);
      }

      return HTMLHeading2Element;

    })(HTMLHeadingElement),
    h3: HTMLHeading3Element = (function(_super) {

      __extends(HTMLHeading3Element, _super);

      function HTMLHeading3Element() {
        var a;
        a = 1 <= arguments.length ? __slice.call(arguments, 0) : [];
        a[0] = "H1";
        HTMLHeading3Element.__super__.constructor.apply(this, a);
      }

      return HTMLHeading3Element;

    })(HTMLHeadingElement),
    h4: HTMLHeading4Element = (function(_super) {

      __extends(HTMLHeading4Element, _super);

      function HTMLHeading4Element() {
        var a;
        a = 1 <= arguments.length ? __slice.call(arguments, 0) : [];
        a[0] = "H1";
        HTMLHeading4Element.__super__.constructor.apply(this, a);
      }

      return HTMLHeading4Element;

    })(HTMLHeadingElement),
    h5: HTMLHeading5Element = (function(_super) {

      __extends(HTMLHeading5Element, _super);

      function HTMLHeading5Element() {
        var a;
        a = 1 <= arguments.length ? __slice.call(arguments, 0) : [];
        a[0] = "H1";
        HTMLHeading5Element.__super__.constructor.apply(this, a);
      }

      return HTMLHeading5Element;

    })(HTMLHeadingElement),
    h6: HTMLHeading6Element = (function(_super) {

      __extends(HTMLHeading6Element, _super);

      function HTMLHeading6Element() {
        var a;
        a = 1 <= arguments.length ? __slice.call(arguments, 0) : [];
        a[0] = "H6";
        HTMLHeading6Element.__super__.constructor.apply(this, a);
      }

      return HTMLHeading6Element;

    })(HTMLHeadingElement),
    head: HTMLHeadElement = (function(_super) {

      __extends(HTMLHeadElement, _super);

      function HTMLHeadElement() {
        var a;
        a = 1 <= arguments.length ? __slice.call(arguments, 0) : [];
        a[0] = "HEAD";
        HTMLHeadElement.__super__.constructor.apply(this, a);
      }

      return HTMLHeadElement;

    })(HTMLElement),
    hr: HTMLHRElement = (function(_super) {

      __extends(HTMLHRElement, _super);

      function HTMLHRElement() {
        var a;
        a = 1 <= arguments.length ? __slice.call(arguments, 0) : [];
        a[0] = "HR";
        HTMLHRElement.__super__.constructor.apply(this, a);
      }

      return HTMLHRElement;

    })(HTMLElement),
    html: HTMLHtmlElement = (function(_super) {

      __extends(HTMLHtmlElement, _super);

      function HTMLHtmlElement() {
        var a;
        a = 1 <= arguments.length ? __slice.call(arguments, 0) : [];
        a[0] = "HTML";
        HTMLHtmlElement.__super__.constructor.apply(this, a);
      }

      return HTMLHtmlElement;

    })(HTMLElement),
    iframe: HTMLIFrameElement = (function(_super) {

      __extends(HTMLIFrameElement, _super);

      function HTMLIFrameElement() {
        var a;
        a = 1 <= arguments.length ? __slice.call(arguments, 0) : [];
        a[0] = "IFRAME";
        HTMLIFrameElement.__super__.constructor.apply(this, a);
      }

      return HTMLIFrameElement;

    })(HTMLElement),
    image: HTMLImageElement = (function(_super) {

      __extends(HTMLImageElement, _super);

      function HTMLImageElement() {
        var a;
        a = 1 <= arguments.length ? __slice.call(arguments, 0) : [];
        a[0] = "IMAGE";
        HTMLImageElement.__super__.constructor.apply(this, a);
      }

      return HTMLImageElement;

    })(HTMLElement),
    input: HTMLInputElement = (function(_super) {

      __extends(HTMLInputElement, _super);

      function HTMLInputElement() {
        var a;
        a = 1 <= arguments.length ? __slice.call(arguments, 0) : [];
        a[0] = "INPUT";
        HTMLInputElement.__super__.constructor.apply(this, a);
      }

      return HTMLInputElement;

    })(HTMLElement),
    ins: HTMLInsElement = (function(_super) {

      __extends(HTMLInsElement, _super);

      function HTMLInsElement() {
        var a;
        a = 1 <= arguments.length ? __slice.call(arguments, 0) : [];
        a[0] = "INS";
        HTMLInsElement.__super__.constructor.apply(this, a);
      }

      return HTMLInsElement;

    })(HTMLElement),
    keygen: HTMLKeygenElement = (function(_super) {

      __extends(HTMLKeygenElement, _super);

      function HTMLKeygenElement() {
        var a;
        a = 1 <= arguments.length ? __slice.call(arguments, 0) : [];
        a[0] = "KEYGEN";
        HTMLKeygenElement.__super__.constructor.apply(this, a);
      }

      return HTMLKeygenElement;

    })(HTMLElement),
    label: HTMLLabelElement = (function(_super) {

      __extends(HTMLLabelElement, _super);

      function HTMLLabelElement() {
        var a;
        a = 1 <= arguments.length ? __slice.call(arguments, 0) : [];
        a[0] = "LABEL";
        HTMLLabelElement.__super__.constructor.apply(this, a);
      }

      return HTMLLabelElement;

    })(HTMLElement),
    legend: HTMLLegendElement = (function(_super) {

      __extends(HTMLLegendElement, _super);

      function HTMLLegendElement() {
        var a;
        a = 1 <= arguments.length ? __slice.call(arguments, 0) : [];
        a[0] = "LEGEND";
        HTMLLegendElement.__super__.constructor.apply(this, a);
      }

      return HTMLLegendElement;

    })(HTMLElement),
    li: HTMLLIElement = (function(_super) {

      __extends(HTMLLIElement, _super);

      function HTMLLIElement() {
        var a;
        a = 1 <= arguments.length ? __slice.call(arguments, 0) : [];
        a[0] = "LI";
        HTMLLIElement.__super__.constructor.apply(this, a);
      }

      return HTMLLIElement;

    })(HTMLElement),
    link: HTMLLinkElement = (function(_super) {

      __extends(HTMLLinkElement, _super);

      function HTMLLinkElement() {
        var a;
        a = 1 <= arguments.length ? __slice.call(arguments, 0) : [];
        a[0] = "LINK";
        HTMLLinkElement.__super__.constructor.apply(this, a);
      }

      return HTMLLinkElement;

    })(HTMLElement),
    map: HTMLMapElement = (function(_super) {

      __extends(HTMLMapElement, _super);

      function HTMLMapElement() {
        var a;
        a = 1 <= arguments.length ? __slice.call(arguments, 0) : [];
        a[0] = "MAP";
        HTMLMapElement.__super__.constructor.apply(this, a);
      }

      return HTMLMapElement;

    })(HTMLElement),
    menu: HTMLMenuElement = (function(_super) {

      __extends(HTMLMenuElement, _super);

      function HTMLMenuElement() {
        var a;
        a = 1 <= arguments.length ? __slice.call(arguments, 0) : [];
        a[0] = "MENU";
        HTMLMenuElement.__super__.constructor.apply(this, a);
      }

      return HTMLMenuElement;

    })(HTMLElement),
    meta: HTMLMetaElement = (function(_super) {

      __extends(HTMLMetaElement, _super);

      function HTMLMetaElement() {
        var a;
        a = 1 <= arguments.length ? __slice.call(arguments, 0) : [];
        a[0] = "META";
        HTMLMetaElement.__super__.constructor.apply(this, a);
      }

      return HTMLMetaElement;

    })(HTMLElement),
    meter: HTMLMeterElement = (function(_super) {

      __extends(HTMLMeterElement, _super);

      function HTMLMeterElement() {
        var a;
        a = 1 <= arguments.length ? __slice.call(arguments, 0) : [];
        a[0] = "METER";
        HTMLMeterElement.__super__.constructor.apply(this, a);
      }

      return HTMLMeterElement;

    })(HTMLElement),
    object: HTMLObjectElement = (function(_super) {

      __extends(HTMLObjectElement, _super);

      function HTMLObjectElement() {
        var a;
        a = 1 <= arguments.length ? __slice.call(arguments, 0) : [];
        a[0] = "OBJECT";
        HTMLObjectElement.__super__.constructor.apply(this, a);
      }

      return HTMLObjectElement;

    })(HTMLElement),
    ol: HTMLOListElement = (function(_super) {

      __extends(HTMLOListElement, _super);

      function HTMLOListElement() {
        var a;
        a = 1 <= arguments.length ? __slice.call(arguments, 0) : [];
        a[0] = "OL";
        HTMLOListElement.__super__.constructor.apply(this, a);
      }

      return HTMLOListElement;

    })(HTMLElement),
    optgroup: HTMLOptGroupElement = (function(_super) {

      __extends(HTMLOptGroupElement, _super);

      function HTMLOptGroupElement() {
        var a;
        a = 1 <= arguments.length ? __slice.call(arguments, 0) : [];
        a[0] = "OPTGROUP";
        HTMLOptGroupElement.__super__.constructor.apply(this, a);
      }

      return HTMLOptGroupElement;

    })(HTMLElement),
    option: HTMLOptionElement = (function(_super) {

      __extends(HTMLOptionElement, _super);

      function HTMLOptionElement() {
        var a;
        a = 1 <= arguments.length ? __slice.call(arguments, 0) : [];
        a[0] = "OPTION";
        HTMLOptionElement.__super__.constructor.apply(this, a);
      }

      return HTMLOptionElement;

    })(HTMLInputElement),
    output: HTMLOutputElement = (function(_super) {

      __extends(HTMLOutputElement, _super);

      function HTMLOutputElement() {
        var a;
        a = 1 <= arguments.length ? __slice.call(arguments, 0) : [];
        a[0] = "OUTPUT";
        HTMLOutputElement.__super__.constructor.apply(this, a);
      }

      return HTMLOutputElement;

    })(HTMLElement),
    p: HTMLParagraphElement = (function(_super) {

      __extends(HTMLParagraphElement, _super);

      function HTMLParagraphElement() {
        var a;
        a = 1 <= arguments.length ? __slice.call(arguments, 0) : [];
        a[0] = "P";
        HTMLParagraphElement.__super__.constructor.apply(this, a);
      }

      return HTMLParagraphElement;

    })(HTMLElement),
    param: HTMLParamElement = (function(_super) {

      __extends(HTMLParamElement, _super);

      function HTMLParamElement() {
        var a;
        a = 1 <= arguments.length ? __slice.call(arguments, 0) : [];
        a[0] = "PARAM";
        HTMLParamElement.__super__.constructor.apply(this, a);
      }

      return HTMLParamElement;

    })(HTMLElement),
    pre: HTMLPreElement = (function(_super) {

      __extends(HTMLPreElement, _super);

      function HTMLPreElement() {
        var a;
        a = 1 <= arguments.length ? __slice.call(arguments, 0) : [];
        a[0] = "PRE";
        HTMLPreElement.__super__.constructor.apply(this, a);
      }

      return HTMLPreElement;

    })(HTMLElement),
    progress: HTMLProgressElement = (function(_super) {

      __extends(HTMLProgressElement, _super);

      function HTMLProgressElement() {
        var a;
        a = 1 <= arguments.length ? __slice.call(arguments, 0) : [];
        a[0] = "PROGRESS";
        HTMLProgressElement.__super__.constructor.apply(this, a);
      }

      return HTMLProgressElement;

    })(HTMLElement),
    quote: HTMLQuoteElement = (function(_super) {

      __extends(HTMLQuoteElement, _super);

      function HTMLQuoteElement() {
        var a;
        a = 1 <= arguments.length ? __slice.call(arguments, 0) : [];
        a[0] = "QUOTE";
        HTMLQuoteElement.__super__.constructor.apply(this, a);
      }

      return HTMLQuoteElement;

    })(HTMLElement),
    script: HTMLScriptElement = (function(_super) {

      __extends(HTMLScriptElement, _super);

      function HTMLScriptElement() {
        var a;
        a = 1 <= arguments.length ? __slice.call(arguments, 0) : [];
        a[0] = "SCRIPT";
        HTMLScriptElement.__super__.constructor.apply(this, a);
      }

      return HTMLScriptElement;

    })(HTMLElement),
    select: HTMLSelectElement = (function(_super) {

      __extends(HTMLSelectElement, _super);

      function HTMLSelectElement() {
        var a;
        a = 1 <= arguments.length ? __slice.call(arguments, 0) : [];
        a[0] = "SELECT";
        HTMLSelectElement.__super__.constructor.apply(this, a);
      }

      return HTMLSelectElement;

    })(HTMLInputElement),
    source: HTMLSourceElement = (function(_super) {

      __extends(HTMLSourceElement, _super);

      function HTMLSourceElement() {
        var a;
        a = 1 <= arguments.length ? __slice.call(arguments, 0) : [];
        a[0] = "SOURCE";
        HTMLSourceElement.__super__.constructor.apply(this, a);
      }

      return HTMLSourceElement;

    })(HTMLElement),
    style: HTMLStyleElement = (function(_super) {

      __extends(HTMLStyleElement, _super);

      function HTMLStyleElement() {
        var a;
        a = 1 <= arguments.length ? __slice.call(arguments, 0) : [];
        a[0] = "STYLE";
        HTMLStyleElement.__super__.constructor.apply(this, a);
      }

      return HTMLStyleElement;

    })(HTMLElement),
    table: HTMLTableElement = (function(_super) {

      __extends(HTMLTableElement, _super);

      function HTMLTableElement() {
        var a;
        a = 1 <= arguments.length ? __slice.call(arguments, 0) : [];
        a[0] = "TABLE";
        HTMLTableElement.__super__.constructor.apply(this, a);
      }

      return HTMLTableElement;

    })(HTMLElement),
    thead: HTMLTableHeadElement = (function(_super) {

      __extends(HTMLTableHeadElement, _super);

      function HTMLTableHeadElement() {
        var a;
        a = 1 <= arguments.length ? __slice.call(arguments, 0) : [];
        a[0] = "THEAD";
        HTMLTableHeadElement.__super__.constructor.apply(this, a);
      }

      return HTMLTableHeadElement;

    })(HTMLElement),
    tbody: HTMLTableBodyElement = (function(_super) {

      __extends(HTMLTableBodyElement, _super);

      function HTMLTableBodyElement() {
        var a;
        a = 1 <= arguments.length ? __slice.call(arguments, 0) : [];
        a[0] = "TBODY";
        HTMLTableBodyElement.__super__.constructor.apply(this, a);
      }

      return HTMLTableBodyElement;

    })(HTMLElement),
    tfoot: HTMLTableFootElement = (function(_super) {

      __extends(HTMLTableFootElement, _super);

      function HTMLTableFootElement() {
        var a;
        a = 1 <= arguments.length ? __slice.call(arguments, 0) : [];
        a[0] = "TFOOT";
        HTMLTableFootElement.__super__.constructor.apply(this, a);
      }

      return HTMLTableFootElement;

    })(HTMLElement),
    td: HTMLTableCellElement = (function(_super) {

      __extends(HTMLTableCellElement, _super);

      function HTMLTableCellElement() {
        var a;
        a = 1 <= arguments.length ? __slice.call(arguments, 0) : [];
        a[0] = "TD";
        HTMLTableCellElement.__super__.constructor.apply(this, a);
      }

      return HTMLTableCellElement;

    })(HTMLElement),
    th: HTMLTableHeadElement = (function(_super) {

      __extends(HTMLTableHeadElement, _super);

      function HTMLTableHeadElement() {
        var a;
        a = 1 <= arguments.length ? __slice.call(arguments, 0) : [];
        a[0] = "TH";
        HTMLTableHeadElement.__super__.constructor.apply(this, a);
      }

      return HTMLTableHeadElement;

    })(HTMLTableCellElement),
    tr: HTMLTableRowElement = (function(_super) {

      __extends(HTMLTableRowElement, _super);

      function HTMLTableRowElement() {
        var a;
        a = 1 <= arguments.length ? __slice.call(arguments, 0) : [];
        a[0] = "TR";
        HTMLTableRowElement.__super__.constructor.apply(this, a);
      }

      return HTMLTableRowElement;

    })(HTMLElement),
    textarea: HTMLTextAreaElement = (function(_super) {

      __extends(HTMLTextAreaElement, _super);

      function HTMLTextAreaElement() {
        var a;
        a = 1 <= arguments.length ? __slice.call(arguments, 0) : [];
        a[0] = "TEXTAREA";
        HTMLTextAreaElement.__super__.constructor.apply(this, a);
      }

      return HTMLTextAreaElement;

    })(HTMLElement),
    title: HTMLTitleElement = (function(_super) {

      __extends(HTMLTitleElement, _super);

      function HTMLTitleElement() {
        var a;
        a = 1 <= arguments.length ? __slice.call(arguments, 0) : [];
        a[0] = "TITLE";
        HTMLTitleElement.__super__.constructor.apply(this, a);
      }

      return HTMLTitleElement;

    })(HTMLElement),
    ul: HTMLUListElement = (function(_super) {

      __extends(HTMLUListElement, _super);

      function HTMLUListElement() {
        var a;
        a = 1 <= arguments.length ? __slice.call(arguments, 0) : [];
        a[0] = "UL";
        HTMLUListElement.__super__.constructor.apply(this, a);
      }

      return HTMLUListElement;

    })(HTMLElement),
    video: HTMLVideoElement = (function(_super) {

      __extends(HTMLVideoElement, _super);

      function HTMLVideoElement() {
        var a;
        a = 1 <= arguments.length ? __slice.call(arguments, 0) : [];
        a[0] = "VIDEO";
        HTMLVideoElement.__super__.constructor.apply(this, a);
      }

      return HTMLVideoElement;

    })(HTMLElement)
  };

  property(Element.prototype, 'tagName', {
    get: function() {
      return this.nodeName;
    }
  });

  property(Element.prototype, 'innerHTML', {
    get: function() {
      var c, h, _i, _len, _ref;
      h = [];
      _ref = this.childNodes;
      for (_i = 0, _len = _ref.length; _i < _len; _i++) {
        c = _ref[_i];
        h.push(c.toString());
      }
      return h.join('');
    },
    set: function(v) {
      var c, fragment, _i, _len, _ref;
      fragment = htmlparse(v, this.ownerDocument);
      _ref = this.childNodes;
      for (_i = 0, _len = _ref.length; _i < _len; _i++) {
        c = _ref[_i];
        c._private.parentNode = null;
        c._private.childIndex = -1;
      }
      this.childNodes.length = 0;
      return this.appendChild(fragment);
    }
  });

  getInnerText = function() {
    var c, t, _i, _len, _ref, _ref1;
    t = [];
    _ref = this.childNodes;
    for (_i = 0, _len = _ref.length; _i < _len; _i++) {
      c = _ref[_i];
      if ((_ref1 = c.nodeType) === Node.TEXT_NODE || _ref1 === Node.CDATA_SECTION_NODE) {
        t.push(c.toString(false, false));
      } else if (c.nodeType !== Node.COMMENT_NODE) {
        t.push(getInnerText.apply(c));
      }
    }
    return t.join('');
  };

  setInnerText = function(text) {
    while (this.hasChildNodes()) {
      this.removeChild(0);
    }
    return this.appendChild(new Text(text, this));
  };

  property(Element.prototype, 'innerText', {
    get: getInnerText,
    set: setInnerText
  });

  property(Element.prototype, 'textContent', {
    get: getInnerText,
    set: setInnerText
  });

  property(Element.prototype, 'id', {
    get: function() {
      return this.attributes['id'];
    },
    set: function(value) {
      var o;
      o = this.ownerDocument != null;
      if (o) {
        if (this.attributes.id != null) {
          delete this.ownerDocument._private.idMap[this.attributes.id];
        }
      }
      if (value === null || value === (void 0) || value === "undefined") {
        return delete this.attributes.id;
      } else {
        if (o) {
          this.ownerDocument._private.idMap[value] = this;
        }
        return this.attributes.id = value;
      }
    }
  });

  property(Element.prototype, 'className', {
    get: function() {
      return this.attributes['class'] || "";
    },
    set: function(value) {
      if (value === null || value === (void 0) || value === "undefined") {
        delete this.attributes["class"];
        return this._private.classes.length = 0;
      } else {
        this.attributes['class'] = value;
        return this._private.classes = value.split(' ');
      }
    }
  });

  property(HTMLInputElement.prototype, 'value', {
    get: function() {
      var _ref;
      return this.attributes.value || ((_ref = this.attributes.type) === 'checkbox' || _ref === 'radio' ? "on" : void 0) || "";
    },
    set: function(v) {
      return this.setAttribute('value', v);
    }
  });

  property(HTMLInputElement.prototype, 'checked', {
    get: function() {
      return this.hasAttribute('checked');
    },
    set: function(v) {
      if (v != null) {
        return this.setAttribute('checked', 'checked');
      } else {
        return this.removeAttribute('checked');
      }
    }
  });

  property(HTMLInputElement.prototype, 'selected', {
    get: function() {
      return this.hasAttribute('selected');
    },
    set: function(v) {
      if (v != null) {
        return this.setAttribute('selected', 'selected');
      } else {
        return this.removeAttribute('selected');
      }
    }
  });

  property(HTMLSelectElement.prototype, 'selectedIndex', {
    get: function() {
      var index, _i, _ref;
      if (!((this._private.selectedIndex != null) && this._private.selectedIndex < this.childNodes.length)) {
        for (index = _i = 0, _ref = this.childNodes.length; 0 <= _ref ? _i < _ref : _i > _ref; index = 0 <= _ref ? ++_i : --_i) {
          if (this.childNodes[index].hasAttribute('selected')) {
            this._private.selectedIndex = index;
          }
        }
      }
      return this._private.selectedIndex || 0;
    },
    set: function(v) {
      var index, _i, _ref;
      if (v < this.childNodes.length) {
        for (index = _i = 0, _ref = this.childNodes.length; 0 <= _ref ? _i < _ref : _i > _ref; index = 0 <= _ref ? ++_i : --_i) {
          if (index === v) {
            this.childNodes[index].setAttribute('selected', 'selected');
          } else {
            this.childNodes[index].removeAttribute('selected');
          }
        }
        this._private.selectedIndex = v;
      }
      return this._private.selectedIndex || 0;
    }
  });

  property(HTMLOptionElement.prototype, 'value', {
    get: function() {
      if (this.hasAttribute('value')) {
        return this.getAttribute('value');
      } else {
        return this.innerText;
      }
    },
    set: function(v) {
      return this.setAttribute('value', v);
    }
  });

  property(HTMLSelectElement.prototype, 'value', {
    get: function() {
      var _ref;
      return (_ref = this.childNodes[this.selectedIndex]) != null ? _ref.value : void 0;
    },
    set: function(v) {
      var child, index, _i, _ref, _results;
      _results = [];
      for (index = _i = 0, _ref = this.childNodes.length; 0 <= _ref ? _i < _ref : _i > _ref; index = 0 <= _ref ? ++_i : --_i) {
        child = this.childNodes[index];
        if (child.value === v) {
          _results.push(this.selectedIndex = index);
        } else {
          _results.push(void 0);
        }
      }
      return _results;
    }
  });

  Attr = (function(_super) {

    __extends(Attr, _super);

    function Attr(name, value) {
      Attr.__super__.constructor.call(this, name, value, Node.ATTRIBUTE_NODE, null);
      this.name = this.nodeName;
      this.value = this.nodeValue;
      this.ownerElement = null;
    }

    return Attr;

  })(Node);

  CData = (function(_super) {

    __extends(CData, _super);

    function CData(value, owner) {
      CData.__super__.constructor.call(this, "#cdata", value, Node.CDATA_SECTION_NODE, owner);
    }

    return CData;

  })(Node);

  Comment = (function(_super) {

    __extends(Comment, _super);

    function Comment(value, owner) {
      Comment.__super__.constructor.call(this, "#comment", value, Node.COMMENT_NODE, owner);
    }

    return Comment;

  })(Node);

  CComment = (function(_super) {

    __extends(CComment, _super);

    function CComment(value, owner) {
      CComment.__super__.constructor.call(this, "#ccomment", "[" + value + "]", Node.COMMENT_NODE, owner);
    }

    return CComment;

  })(Node);

  Text = (function(_super) {

    __extends(Text, _super);

    function Text(value, owner) {
      Text.__super__.constructor.call(this, "#text", value, Node.TEXT_NODE, owner);
    }

    return Text;

  })(Node);

  property(Text.prototype, 'data', {
    set: function(v) {
      return this.nodeValue = htmlescape(v);
    }
  });

  DocumentFragment = (function(_super) {

    __extends(DocumentFragment, _super);

    function DocumentFragment(owner) {
      DocumentFragment.__super__.constructor.call(this, "#document-fragment", null, Node.DOCUMENT_FRAGMENT_NODE, owner);
    }

    DocumentFragment.prototype.toString = function(pretty, deep) {
      var c, r, ret, _i, _len, _ref;
      if (pretty == null) {
        pretty = false;
      }
      if (deep == null) {
        deep = true;
      }
      ret = [];
      r = 0;
      _ref = this.childNodes;
      for (_i = 0, _len = _ref.length; _i < _len; _i++) {
        c = _ref[_i];
        ret[r++] = c.toString(pretty, deep);
      }
      return ret.join('');
    };

    return DocumentFragment;

  })(Node);

  property(DocumentFragment.prototype, 'parentNode', {
    set: function(v) {
      throw Error("DocumentFragment cannot have a parentNode");
    }
  });

  Document = (function(_super) {

    __extends(Document, _super);

    function Document() {
      var a, _ref;
      a = 1 <= arguments.length ? __slice.call(arguments, 0) : [];
      if ((_ref = a[0]) == null) {
        a[0] = "#document";
      }
      a[2] = Node.DOCUMENT_NODE;
      Document.__super__.constructor.apply(this, a);
      this.documentElement = this;
      this.documentURI = null;
      this._private = extend(this._private, {
        idMap: {}
      });
    }

    Document.prototype.createCDATASection = function(value) {
      return new CData(value, this);
    };

    Document.prototype.createComment = function(value) {
      return new Comment(value, this);
    };

    Document.prototype.createCComment = function(value) {
      return new CComment(value, this);
    };

    Document.prototype.createDocumentFragment = function() {
      return new DocumentFragment(this);
    };

    Document.prototype.createElement = function(name) {
      var nodeClass;
      nodeClass = ELEMENT_MAP[name != null ? name.toLowerCase() : void 0];
      if (!(nodeClass != null)) {
        return new ELEMENT_MAP['_'](name.toUpperCase());
      } else {
        return new nodeClass(name.toUpperCase(), null, null, this);
      }
    };

    Document.prototype.createEntityReference = NotSupported;

    Document.prototype.createEvent = function(type) {
      switch (type) {
        case "MutationEvents":
          return new MutationEvent();
        default:
          return new Event();
      }
    };

    Document.prototype.createTextNode = function(text) {
      return new Text(text, this);
    };

    Document.prototype.getElementById = function(id) {
      return this._private.idMap[id];
    };

    return Document;

  })(Element);

  HTMLDocument = (function(_super) {

    __extends(HTMLDocument, _super);

    function HTMLDocument() {
      HTMLDocument.__super__.constructor.call(this, "HTML", null, Node.DOCUMENT_NODE, this);
      Document.prototype.appendChild.call(this, this.createElement('head'));
      Document.prototype.appendChild.call(this, this.createElement('body'));
      this.head = this.childNodes[0];
      this.body = this.childNodes[1];
      this._private = extend(this._private, {
        matcher: matcher.init(global, this)
      });
    }

    HTMLDocument.prototype.hasChildNodes = function() {
      return true;
    };

    HTMLDocument.prototype.insertBefore = NotSupported;

    HTMLDocument.prototype.appendChild = NotSupported;

    HTMLDocument.prototype.removeChild = NotSupported;

    HTMLDocument.prototype.replaceChild = NotSupported;

    HTMLDocument.prototype.write = NotSupported;

    HTMLDocument.prototype.writeln = NotSupported;

    return HTMLDocument;

  })(Document);

  exports.createDocument = function() {
    return new HTMLDocument();
  };

  exports.registerGlobals = function(g) {
    var c, tagName, _results;
    g.Element = Element;
    g.Node = Node;
    g.Document = Document;
    g.DocumentFragment = DocumentFragment;
    g.NodeList = Array;
    g.Event = Event;
    _results = [];
    for (tagName in ELEMENT_MAP) {
      c = ELEMENT_MAP[tagName];
      _results.push(g[c.name] = c);
    }
    return _results;
  };

}).call(this);
